{"version":3,"sources":["../packages/react/src/index.ts","../packages/react/src/api/client.ts","../packages/react/src/runtime/aomi-runtime.tsx","../packages/react/src/runtime/hooks.ts","../packages/react/src/runtime/orchestration.ts","../packages/react/src/utils/conversion.ts","../packages/react/src/runtime/utils.ts","../packages/react/src/runtime/backend-state.ts","../packages/react/src/runtime/message-converter.ts","../packages/react/src/runtime/polling-controller.ts","../packages/react/src/runtime/thread-list.tsx","../packages/react/src/state/thread-context.tsx","../packages/react/src/state/thread-store.ts","../packages/react/src/utils/wallet.ts","../packages/react/src/lib/utils.ts"],"sourcesContent":["export { BackendApi } from \"./api/client\";\nexport type {\n  BackendSessionResponse,\n  SessionMetadata,\n  CreateSessionResponse,\n  SessionMessage,\n  SessionResponsePayload,\n  SystemResponsePayload,\n  SystemUpdate,\n} from \"./api/types\";\n\nexport { AomiRuntimeProvider } from \"./runtime/aomi-runtime\";\nexport { useRuntimeActions, RuntimeActionsProvider } from \"./runtime/hooks\";\n\nexport {\n  ThreadContextProvider,\n  useThreadContext,\n  useCurrentThreadMetadata,\n  useCurrentThreadMessages,\n} from \"./state/thread-context\";\nexport type { ThreadMetadata, ThreadStatus } from \"./state/types\";\n\nexport { toInboundSystem as constructSystemMessage, toInboundMessage as constructThreadMessage } from \"./utils/conversion\";\nexport { WalletSystemMessageEmitter, formatAddress, getNetworkName } from \"./utils/wallet\";\nexport type { WalletButtonState, WalletFooterProps } from \"./utils/wallet\";\n\nexport { cn } from \"./lib/utils\";\n","import type {\n  BackendSessionResponse,\n  SessionMetadata,\n  CreateSessionResponse,\n  SessionMessage,\n  SessionResponsePayload,\n  SystemResponsePayload,\n  SystemUpdate,\n} from \"./types\";\n\nfunction toQueryString(payload: Record<string, unknown>): string {\n  const params = new URLSearchParams();\n  for (const [key, value] of Object.entries(payload)) {\n    if (value === undefined || value === null) continue;\n    params.set(key, String(value));\n  }\n  const qs = params.toString();\n  return qs ? `?${qs}` : \"\";\n}\n\nasync function postState<T>(\n  backendUrl: string,\n  path: string,\n  payload: Record<string, unknown>\n): Promise<T> {\n  const query = toQueryString(payload);\n  const url = `${backendUrl}${path}${query}`;\n  console.log(\"ðŸ”µ [postState] URL:\", url);\n  console.log(\"ðŸ”µ [postState] Payload:\", payload);\n\n  const response = await fetch(url, {\n    method: \"POST\",\n  });\n  console.log(\"ðŸ”µ [postState] Response status:\", response.status);\n\n  if (!response.ok) {\n    console.error(\"ðŸ”´ [postState] Error:\", response.status, response.statusText);\n    throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n  }\n\n  const data = (await response.json()) as T;\n  console.log(\"ðŸŸ¢ [postState] Success:\", data);\n  return data;\n}\n\nexport class BackendApi {\n  private connectionStatus = false;\n  private eventSource: EventSource | null = null;\n  private updatesEventSource: EventSource | null = null;\n\n  constructor(private readonly backendUrl: string) {}\n\n  async fetchState(sessionId: string): Promise<SessionResponsePayload> {\n    console.log(\"ðŸ”µ [fetchState] Called with sessionId:\", sessionId);\n    const url = `${this.backendUrl}/api/state?session_id=${encodeURIComponent(sessionId)}`;\n    console.log(\"ðŸ”µ [fetchState] URL:\", url);\n\n    const response = await fetch(url);\n    console.log(\"ðŸ”µ [fetchState] Response status:\", response.status, response.statusText);\n\n    if (!response.ok) {\n      console.error(\"ðŸ”´ [fetchState] Error:\", response.status, response.statusText);\n      throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n    }\n\n    const data = (await response.json()) as SessionResponsePayload;\n    console.log(\"ðŸŸ¢ [fetchState] Success:\", data);\n    return data;\n  }\n\n  async postChatMessage(sessionId: string, message: string): Promise<SessionResponsePayload> {\n    console.log(\"ðŸ”µ [postChatMessage] Called with sessionId:\", sessionId, \"message:\", message);\n    const result = await postState<SessionResponsePayload>(this.backendUrl, \"/api/chat\", {\n      message,\n      session_id: sessionId,\n    });\n    console.log(\"ðŸŸ¢ [postChatMessage] Success:\", result);\n    return result;\n  }\n\n  async postSystemMessage(sessionId: string, message: string): Promise<SystemResponsePayload> {\n    console.log(\"ðŸ”µ [postSystemMessage] Called with sessionId:\", sessionId, \"message:\", message);\n    const result = await postState<SystemResponsePayload>(this.backendUrl, \"/api/system\", {\n      message,\n      session_id: sessionId,\n    });\n    console.log(\"ðŸŸ¢ [postSystemMessage] Success:\", result);\n    return result;\n  }\n\n  async postInterrupt(sessionId: string): Promise<SessionResponsePayload> {\n    console.log(\"ðŸ”µ [postInterrupt] Called with sessionId:\", sessionId);\n    const result = await postState<SessionResponsePayload>(this.backendUrl, \"/api/interrupt\", {\n      session_id: sessionId,\n    });\n    console.log(\"ðŸŸ¢ [postInterrupt] Success:\", result);\n    return result;\n  }\n\n  disconnectSSE(): void {\n    if (this.eventSource) {\n      this.eventSource.close();\n      this.eventSource = null;\n    }\n    this.setConnectionStatus(false);\n  }\n\n  setConnectionStatus(on: boolean): void {\n    this.connectionStatus = on;\n  }\n\n  async connectSSE(sessionId: string, publicKey?: string) {\n    this.disconnectSSE();\n\n    try {\n      const url = new URL(`${this.backendUrl}/api/chat/stream`);\n      url.searchParams.set(\"session_id\", sessionId);\n      if (publicKey) {\n        url.searchParams.set(\"public_key\", publicKey);\n      }\n\n      this.eventSource = new EventSource(url.toString());\n\n      this.eventSource.onopen = () => {\n        console.log(\"ðŸŒ SSE connection opened to:\", url.toString());\n        this.setConnectionStatus(true);\n      };\n\n      this.eventSource.onmessage = (event) => {\n        try {\n          JSON.parse(event.data);\n        } catch (error) {\n          console.error(\"Failed to parse SSE data:\", error);\n        }\n      };\n\n      this.eventSource.onerror = (error) => {\n        console.error(\"SSE connection error:\", error);\n      };\n    } catch (error) {\n      console.error(\"Failed to establish SSE connection:\", error);\n      this.handleConnectionError(sessionId, publicKey);\n    }\n  }\n\n  private handleConnectionError(sessionId: string, publicKey?: string): void {\n    this.setConnectionStatus(false);\n    let attempt = 0;\n    const total = 3;\n    if (attempt < total) {\n      attempt++;\n      console.log(`Attempting to reconnect (${attempt}/${total})...`);\n\n      setTimeout(() => {\n        this.connectSSE(sessionId, publicKey);\n      }, 100);\n    } else {\n      console.error(\"Max reconnection attempts reached\");\n      this.setConnectionStatus(false);\n    }\n  }\n\n  subscribeToUpdates(\n    onUpdate: (update: SystemUpdate) => void,\n    onError?: (error: unknown) => void\n  ): () => void {\n    if (this.updatesEventSource) {\n      this.updatesEventSource.close();\n    }\n\n    const updatesUrl = new URL(\"/api/updates\", this.backendUrl).toString();\n    this.updatesEventSource = new EventSource(updatesUrl);\n\n    this.updatesEventSource.onmessage = (event) => {\n      try {\n        const parsed = JSON.parse(event.data) as SystemUpdate;\n        onUpdate(parsed);\n      } catch (error) {\n        console.error(\"Failed to parse system update SSE:\", error);\n        onError?.(error);\n      }\n    };\n\n    this.updatesEventSource.onerror = (error) => {\n      console.error(\"System updates SSE error:\", error);\n      onError?.(error);\n    };\n\n    return () => {\n      if (this.updatesEventSource) {\n        this.updatesEventSource.close();\n        this.updatesEventSource = null;\n      }\n    };\n  }\n\n  async fetchThreads(publicKey: string): Promise<SessionMetadata[]> {\n    console.log(\"ðŸ”µ [fetchThreads] Called with publicKey:\", publicKey);\n    const url = `${this.backendUrl}/api/sessions?public_key=${encodeURIComponent(publicKey)}`;\n    console.log(\"ðŸ”µ [fetchThreads] URL:\", url);\n\n    const response = await fetch(url);\n    console.log(\"ðŸ”µ [fetchThreads] Response status:\", response.status);\n\n    if (!response.ok) {\n      console.error(\"ðŸ”´ [fetchThreads] Error:\", response.status);\n      throw new Error(`Failed to fetch threads: HTTP ${response.status}`);\n    }\n\n    const data = (await response.json()) as SessionMetadata[];\n    console.log(\"ðŸŸ¢ [fetchThreads] Success:\", data);\n    return data;\n  }\n\n  async createThread(publicKey?: string, title?: string): Promise<CreateSessionResponse> {\n    console.log(\"ðŸ”µ [createThread] Called with publicKey:\", publicKey, \"title:\", title);\n    const body: Record<string, string> = {};\n    if (publicKey) {\n      body.public_key = publicKey;\n    }\n    if (title) {\n      body.title = title;\n    }\n    console.log(\"ðŸ”µ [createThread] Request body:\", body);\n\n    const url = `${this.backendUrl}/api/sessions`;\n    console.log(\"ðŸ”µ [createThread] URL:\", url);\n\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify(body),\n    });\n    console.log(\"ðŸ”µ [createThread] Response status:\", response.status);\n\n    if (!response.ok) {\n      console.error(\"ðŸ”´ [createThread] Error:\", response.status);\n      throw new Error(`Failed to create thread: HTTP ${response.status}`);\n    }\n\n    const data = (await response.json()) as CreateSessionResponse;\n    console.log(\"ðŸŸ¢ [createThread] Success:\", data);\n    return data;\n  }\n\n  async archiveThread(sessionId: string): Promise<void> {\n    console.log(\"ðŸ”µ [archiveThread] Called with sessionId:\", sessionId);\n    const url = `${this.backendUrl}/api/sessions/${encodeURIComponent(sessionId)}/archive`;\n    console.log(\"ðŸ”µ [archiveThread] URL:\", url);\n\n    const response = await fetch(url, { method: \"POST\" });\n    console.log(\"ðŸ”µ [archiveThread] Response status:\", response.status);\n\n    if (!response.ok) {\n      console.error(\"ðŸ”´ [archiveThread] Error:\", response.status);\n      throw new Error(`Failed to archive thread: HTTP ${response.status}`);\n    }\n    console.log(\"ðŸŸ¢ [archiveThread] Success\");\n  }\n\n  async unarchiveThread(sessionId: string): Promise<void> {\n    console.log(\"ðŸ”µ [unarchiveThread] Called with sessionId:\", sessionId);\n    const url = `${this.backendUrl}/api/sessions/${encodeURIComponent(sessionId)}/unarchive`;\n    console.log(\"ðŸ”µ [unarchiveThread] URL:\", url);\n\n    const response = await fetch(url, { method: \"POST\" });\n    console.log(\"ðŸ”µ [unarchiveThread] Response status:\", response.status);\n\n    if (!response.ok) {\n      console.error(\"ðŸ”´ [unarchiveThread] Error:\", response.status);\n      throw new Error(`Failed to unarchive thread: HTTP ${response.status}`);\n    }\n    console.log(\"ðŸŸ¢ [unarchiveThread] Success\");\n  }\n\n  async deleteThread(sessionId: string): Promise<void> {\n    console.log(\"ðŸ”µ [deleteThread] Called with sessionId:\", sessionId);\n    const url = `${this.backendUrl}/api/sessions/${encodeURIComponent(sessionId)}`;\n    console.log(\"ðŸ”µ [deleteThread] URL:\", url);\n\n    const response = await fetch(url, { method: \"DELETE\" });\n    console.log(\"ðŸ”µ [deleteThread] Response status:\", response.status);\n\n    if (!response.ok) {\n      console.error(\"ðŸ”´ [deleteThread] Error:\", response.status);\n      throw new Error(`Failed to delete thread: HTTP ${response.status}`);\n    }\n    console.log(\"ðŸŸ¢ [deleteThread] Success\");\n  }\n\n  async renameThread(sessionId: string, newTitle: string): Promise<void> {\n    console.log(\"ðŸ”µ [renameThread] Called with sessionId:\", sessionId, \"newTitle:\", newTitle);\n    const url = `${this.backendUrl}/api/sessions/${encodeURIComponent(sessionId)}`;\n    console.log(\"ðŸ”µ [renameThread] URL:\", url);\n\n    const response = await fetch(url, {\n      method: \"PATCH\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({ title: newTitle }),\n    });\n    console.log(\"ðŸ”µ [renameThread] Response status:\", response.status);\n\n    if (!response.ok) {\n      console.error(\"ðŸ”´ [renameThread] Error:\", response.status);\n      throw new Error(`Failed to rename thread: HTTP ${response.status}`);\n    }\n    console.log(\"ðŸŸ¢ [renameThread] Success\");\n  }\n}\n","\"use client\";\n\nimport { useCallback, useEffect, useRef } from \"react\";\nimport type { MutableRefObject, ReactNode } from \"react\";\nimport {\n  AssistantRuntimeProvider,\n  type AppendMessage,\n  type AssistantRuntime,\n  type ThreadMessageLike,\n  useExternalStoreRuntime,\n} from \"@assistant-ui/react\";\n\nimport { RuntimeActionsProvider } from \"./hooks\";\nimport { useRuntimeOrchestration } from \"./orchestration\";\nimport { getTempIdForSession, isSessionReady, isSessionRunning, resolveSessionId } from \"./backend-state\";\nimport { isPlaceholderTitle, isTempThreadId } from \"./utils\";\nimport type { MessageConverter } from \"./message-converter\";\nimport { fetchPubkeyThreads, useThreadListAdapter, type ThreadListAdapter } from \"./thread-list\";\nimport { useThreadContext } from \"../state/thread-context\";\nimport type { ThreadContext } from \"../state/thread-store\";\n\nexport type AomiRuntimeProviderProps = {\n  children: ReactNode;\n  backendUrl?: string;\n  publicKey?: string;\n};\n\nexport function AomiRuntimeProvider({\n  children,\n  backendUrl = \"http://localhost:8080\",\n  publicKey,\n}: Readonly<AomiRuntimeProviderProps>) {\n  // Get contextual state from ThreadContextProvider\n  const threadContext = useThreadContext();\n  const threadContextRef = useRef(threadContext);\n  threadContextRef.current = threadContext;\n  const currentThreadId = threadContext.currentThreadId;\n\n  // hook to BackendApi, PollingController, and MessageConverter\n  // in one render cycle, init them if needed\n  // apply changes to ThreadContext based on BE state & polling interval\n  const {\n    backendStateRef,\n    polling,\n    messageConverter,\n    isRunning,\n    setIsRunning,\n    syncThreadState,\n    backendApiRef,\n  } = useRuntimeOrchestration(backendUrl, threadContextRef);\n\n  // Concurrency checkpoint ðŸ¤\n  // make a thread-safe smart pointer for other hooks that useEffect\n  const currentThreadIdRef = useRef(currentThreadId);\n  currentThreadIdRef.current = currentThreadId;\n  // Syncs thread state with backend when currentThreadId changes\n  useEffect(() => {\n    void syncThreadState(currentThreadId);\n  }, [syncThreadState, currentThreadId]);\n\n  // Updates isRunning state based on whether the current thread is running\n  useEffect(() => {\n    setIsRunning(isSessionRunning(backendStateRef.current, currentThreadId));\n  }, [backendStateRef, setIsRunning, currentThreadId]);\n\n  const currentMessages = threadContext.getThreadMessages(currentThreadId);\n\n  // Fetches thread list from backend when publicKey is available\n  useEffect(() => {\n    if (!publicKey) return;\n    void fetchPubkeyThreads(publicKey, backendApiRef, threadContextRef);\n  }, [backendApiRef, publicKey, threadContextRef]);\n\n  // Subscribes to backend updates and handles title change events\n  useEffect(() => {\n    const unsubscribe = backendApiRef.current.subscribeToUpdates((update) => {\n      if (update.type !== \"TitleChanged\") return;\n      const sessionId = update.data.session_id;\n      const newTitle = update.data.new_title;\n\n      const backendState = backendStateRef.current;\n      const targetThreadId =\n        getTempIdForSession(backendState, sessionId) ??\n        resolveSessionId(backendState, sessionId);\n      const normalizedTitle = isPlaceholderTitle(newTitle) ? \"\" : newTitle;\n      threadContext.setThreadMetadata((prev) => {\n        const next = new Map(prev);\n        const existing = next.get(targetThreadId);\n        const nextStatus = existing?.status === \"archived\" ? \"archived\" : \"regular\";\n        next.set(targetThreadId, {\n          title: normalizedTitle,\n          status: nextStatus,\n          lastActiveAt: existing?.lastActiveAt ?? new Date().toISOString(),\n        });\n        return next;\n      });\n      if (!isPlaceholderTitle(newTitle) && backendState.creatingThreadId === targetThreadId) {\n        backendState.creatingThreadId = null;\n      }\n    });\n\n    return () => {\n      unsubscribe?.();\n    };\n  }, [backendApiRef, backendStateRef, threadContext]);\n\n  // Flushes pending chat messages when a temp thread is ready and mapped\n  useEffect(() => {\n    if (!isTempThreadId(currentThreadId)) return;\n    if (!isSessionReady(backendStateRef.current, currentThreadId)) return;\n    void messageConverter.flushPendingSession(currentThreadId);\n  }, [messageConverter, backendStateRef, currentThreadId]);\n\n  // Flushes pending system messages after user messages are sent\n  useEffect(() => {\n    if (isTempThreadId(currentThreadId)) return;\n    const hasUserMessages = currentMessages.some((msg) => msg.role === \"user\");\n    if (hasUserMessages) {\n      void messageConverter.flushPendingSystem(currentThreadId);\n    }\n  }, [currentMessages, messageConverter, currentThreadId]);\n\n  // Stops all polling when the provider unmounts\n  useEffect(() => {\n    return () => {\n      polling.stopAll();\n    };\n  }, [polling]);\n\n  const { setMessages, onNew, onCancel, sendSystemMessage } = useRuntimeCallbacks({\n    currentThreadIdRef,\n    messageConverter,\n    threadContextRef,\n  });\n\n  const threadListAdapter: ThreadListAdapter = useThreadListAdapter({\n    backendApiRef,\n    backendStateRef,\n    currentThreadIdRef,\n    polling,\n    publicKey,\n    setIsRunning,\n    threadContext,\n    threadContextRef,\n  });\n\n  const runtime: AssistantRuntime = useExternalStoreRuntime({\n    messages: currentMessages,\n    setMessages,\n    isRunning,\n    onNew,\n    onCancel,\n    convertMessage: (msg) => msg,\n    adapters: { threadList: threadListAdapter },\n  });\n\n  return (\n    <RuntimeActionsProvider value={{ sendSystemMessage }}>\n      <AssistantRuntimeProvider runtime={runtime}>{children}</AssistantRuntimeProvider>\n    </RuntimeActionsProvider>\n  );\n}\n\ntype RuntimeCallbacksParams = {\n  currentThreadIdRef: MutableRefObject<string>;\n  messageConverter: MessageConverter;\n  threadContextRef: MutableRefObject<ThreadContext>;\n};\n\nfunction useRuntimeCallbacks({\n  currentThreadIdRef,\n  messageConverter,\n  threadContextRef,\n}: RuntimeCallbacksParams) {\n  const setMessages = useCallback(\n    (messages: readonly ThreadMessageLike[]) => {\n      threadContextRef.current.setThreadMessages(currentThreadIdRef.current, [...messages]);\n    },\n    [currentThreadIdRef, threadContextRef]\n  );\n\n  const onNew = useCallback(\n    (message: AppendMessage) =>\n      messageConverter.outbound(message, currentThreadIdRef.current),\n    [currentThreadIdRef, messageConverter]\n  );\n\n  const onCancel = useCallback(\n    () => messageConverter.cancel(currentThreadIdRef.current),\n    [currentThreadIdRef, messageConverter]\n  );\n\n  const sendSystemMessage = useCallback(\n    (message: string) =>\n      messageConverter.outboundSystem(currentThreadIdRef.current, message),\n    [currentThreadIdRef, messageConverter]\n  );\n\n  return { setMessages, onNew, onCancel, sendSystemMessage };\n}\n","\"use client\";\n\nimport { createContext, useContext } from \"react\";\n\nexport type RuntimeActions = {\n  sendSystemMessage: (message: string) => Promise<void>;\n};\n\nconst RuntimeActionsContext = createContext<RuntimeActions | undefined>(undefined);\n\nexport const RuntimeActionsProvider = RuntimeActionsContext.Provider;\n\nexport function useRuntimeActions(): RuntimeActions {\n  const context = useContext(RuntimeActionsContext);\n  if (!context) {\n    throw new Error(\"useRuntimeActions must be used within AomiRuntimeProvider\");\n  }\n  return context;\n}\n","import type { MutableRefObject } from \"react\";\nimport { useCallback, useRef, useState } from \"react\";\n\nimport { BackendApi } from \"../api/client\";\nimport type { SessionMessage } from \"../api/types\";\nimport type { ThreadContext } from \"../state/thread-store\";\nimport { MessageConverter } from \"./message-converter\";\nimport { PollingController } from \"./polling-controller\";\nimport {\n  clearSkipInitialFetch,\n  createBakendState,\n  isSessionReady,\n  resolveSessionId,\n  shouldSkipInitialFetch,\n  type BakendState,\n} from \"./backend-state\";\n\nexport function useRuntimeOrchestration(\n  backendUrl: string,\n  threadContextRef: MutableRefObject<ThreadContext>\n) {\n  const backendApiRef = useRef<BackendApi | null>(null);\n  if (!backendApiRef.current) {\n    // Init whenever the backendUrl changes or null\n    backendApiRef.current = new BackendApi(backendUrl);\n  }\n  // useRef always graps BakendState if not null, otherwise runs createBakendState()\n  const backendApi = backendApiRef as MutableRefObject<BackendApi>;\n  const backendStateRef = useRef<BakendState>(createBakendState());\n\n  // Local state inside the DOM tree, re-init everytime\n  const [isRunning, setIsRunning] = useState(false);\n\n  const messageConverterRef = useRef<MessageConverter | null>(null);\n  const pollingRef = useRef<PollingController | null>(null);\n\n  if (!pollingRef.current) {\n    // Init once, polling is an singleton state machine with ref of backend, and msgs functions \n    // keeps a map of threadId -> intervalId\n    pollingRef.current = new PollingController({\n      backendApiRef: backendApi,\n      backendStateRef,\n      // find the right time to run applyMessages\n      applyMessages: (threadId: string, msgs?: SessionMessage[] | null) => {\n        messageConverterRef.current?.inbound(threadId, msgs);\n      },\n      onStop: (threadId: string) => {\n        if (threadContextRef.current.currentThreadId === threadId) {\n          setIsRunning(false);\n        }\n      },\n    });\n  }\n\n  if (!messageConverterRef.current) {\n    // Singleton processor interface, stateless\n    messageConverterRef.current = new MessageConverter({\n      backendApiRef: backendApi,\n      backendStateRef,\n      threadContextRef,\n      polling: pollingRef.current,\n      setGlobalIsRunning: setIsRunning,\n    });\n  }\n  // - On mount / page load: it runs for the current thread to pull existing messages and processing state.\n  // - On thread switch: it runs for the newly selected thread to load its messages and start/stop polling.\n  // - New temp thread: it does nothing until the temp thread is mapped to a backend thread (isSessionReady becomes true).\n  const syncThreadState = useCallback(\n    async (threadId: string) => {\n      const backendState = backendStateRef.current;\n      const isCurrentThread = threadContextRef.current.currentThreadId === threadId;\n      //  If this thread is marked to skip the initial fetch, clear the flag and stop \n      if (shouldSkipInitialFetch(backendState, threadId)) {\n        clearSkipInitialFetch(backendState, threadId);\n        if (isCurrentThread) {\n          setIsRunning(false);\n        }\n        return;\n      }\n      //  If the thread isnâ€™t â€œreadyâ€ yet (e.g., temp thread not mapped), stop and return \n      if (!isSessionReady(backendState, threadId)) {\n        if (isCurrentThread) {\n          setIsRunning(false);\n        }\n        return;\n      }\n      // The thread had registered with BE! \n      const sessionId = resolveSessionId(backendState, threadId);\n      try {\n        // ðŸŒ¸ BE -> UI sync point with POST\n        const state = await backendApi.current.fetchState(sessionId);\n        // conversion from BE type to UI type and apply to ThreadContext\n        messageConverterRef.current?.inbound(threadId, state.messages);\n        if (state.is_processing) {\n          if (isCurrentThread) {\n            setIsRunning(true);\n          }\n          pollingRef.current?.start(threadId);\n        } else {\n          if (isCurrentThread) {\n            setIsRunning(false);\n          }\n        }\n      } catch (error) {\n        console.error(\"Failed to fetch initial state:\", error);\n        if (isCurrentThread) {\n          setIsRunning(false);\n        }\n      }\n    },\n    [\n      backendApi,\n      backendStateRef,\n      pollingRef,\n      messageConverterRef,\n      setIsRunning,\n      threadContextRef,\n    ]\n  );\n\n  return {\n    backendStateRef,\n    polling: pollingRef.current!,\n    messageConverter: messageConverterRef.current!,\n    isRunning,\n    setIsRunning,\n    syncThreadState,\n    backendApiRef: backendApi,\n  };\n}\n","import type { ThreadMessageLike } from \"@assistant-ui/react\";\n\nimport type { SessionMessage } from \"../api/types\";\n\ntype MessageContentPart = Exclude<ThreadMessageLike[\"content\"], string> extends readonly (infer U)[] ? U : never;\n\nexport function toInboundMessage(msg: SessionMessage): ThreadMessageLike | null {\n  if (msg.sender === \"system\") return null;\n\n  const content: MessageContentPart[] = [];\n  const role: ThreadMessageLike[\"role\"] = msg.sender === \"user\" ? \"user\" : \"assistant\";\n\n  if (msg.content) {\n    content.push({ type: \"text\" as const, text: msg.content });\n  }\n\n  const [topic, toolContent] = parseToolStream(msg.tool_stream) ?? [];\n  if (topic && toolContent) {\n    content.push({\n      type: \"tool-call\" as const,\n      toolCallId: `tool_${Date.now()}`,\n      toolName: topic,\n      args: undefined,\n      result: (() => {\n        try {\n          return JSON.parse(toolContent);\n        } catch {\n          return { args: toolContent };\n        }\n      })(),\n    });\n  }\n\n  const threadMessage = {\n    role,\n    content: (content.length > 0 ? content : [{ type: \"text\" as const, text: \"\" }]) as ThreadMessageLike[\"content\"],\n    ...(msg.timestamp && { createdAt: new Date(msg.timestamp) }),\n  } satisfies ThreadMessageLike;\n\n  return threadMessage;\n}\n\nexport function toInboundSystem(msg: SessionMessage): ThreadMessageLike | null {\n  const [topic] = parseToolStream(msg.tool_stream) ?? [];\n  const messageText = topic || msg.content || \"\";\n  const timestamp = parseTimestamp(msg.timestamp);\n\n  if (!messageText.trim()) return null;\n\n  return {\n    role: \"system\",\n    content: [{ type: \"text\", text: messageText }],\n    ...(timestamp && { createdAt: timestamp }),\n  } satisfies ThreadMessageLike;\n}\n\nexport function constructUITool(): string {\n  return \"\";\n}\n\nfunction parseTimestamp(timestamp?: string) {\n  if (!timestamp) return undefined;\n  const parsed = new Date(timestamp);\n  return Number.isNaN(parsed.valueOf()) ? undefined : parsed;\n}\n\nfunction parseToolStream(toolStream: SessionMessage[\"tool_stream\"]): [string, string] | null {\n  if (!toolStream) return null;\n\n  if (Array.isArray(toolStream) && toolStream.length === 2) {\n    const [topic, content] = toolStream;\n    return [String(topic), content];\n  }\n\n  if (typeof toolStream === \"object\") {\n    const topic = (toolStream as { topic?: unknown }).topic;\n    const content = (toolStream as { content?: unknown }).content;\n    return topic ? [String(topic), String(content)] : null;\n  }\n\n  return null;\n}\n","export const isTempThreadId = (id: string) => id.startsWith(\"temp-\");\n\nexport const parseTimestamp = (value?: string | number) => {\n  if (value === undefined || value === null) return 0;\n  if (typeof value === \"number\") {\n    return Number.isFinite(value) ? (value < 1e12 ? value * 1000 : value) : 0;\n  }\n\n  const numeric = Number(value);\n  if (!Number.isNaN(numeric)) {\n    return numeric < 1e12 ? numeric * 1000 : numeric;\n  }\n\n  const ts = Date.parse(value);\n  return Number.isNaN(ts) ? 0 : ts;\n};\n\nexport const isPlaceholderTitle = (title?: string) => {\n  const normalized = title?.trim() ?? \"\";\n  return !normalized || normalized.startsWith(\"#[\");\n};\n","import { isTempThreadId } from \"./utils\";\n\nexport type BakendState = {\n  tempToSessionId: Map<string, string>;\n  skipInitialFetch: Set<string>;\n  pendingSession: Map<string, string[]>;\n  pendingSystem: Map<string, string[]>;\n  runningSessions: Set<string>;\n  creatingThreadId: string | null;\n  createThreadPromise: Promise<void> | null;\n};\n\nexport function createBakendState(): BakendState {\n  return {\n    tempToSessionId: new Map(),\n    skipInitialFetch: new Set(),\n    pendingSession: new Map(),\n    pendingSystem: new Map(),\n    runningSessions: new Set(),\n    creatingThreadId: null,\n    createThreadPromise: null,\n  };\n}\n\nexport function resolveSessionId(state: BakendState, threadId: string): string {\n  return state.tempToSessionId.get(threadId) ?? threadId;\n}\n\nexport function isSessionReady(state: BakendState, threadId: string): boolean {\n  if (!isTempThreadId(threadId)) return true;\n  return state.tempToSessionId.has(threadId);\n}\n\nexport function setBackendMapping(\n  state: BakendState,\n  tempId: string,\n  backendId: string\n) {\n  state.tempToSessionId.set(tempId, backendId);\n}\n\nexport function getTempIdForSession(\n  state: BakendState,\n  backendId: string\n): string | undefined {\n  for (const [tempId, id] of state.tempToSessionId.entries()) {\n    if (id === backendId) return tempId;\n  }\n  return undefined;\n}\n\nexport function skipFirstFetch(state: BakendState, threadId: string) {\n  state.skipInitialFetch.add(threadId);\n}\n\nexport function shouldSkipInitialFetch(\n  state: BakendState,\n  threadId: string\n): boolean {\n  return state.skipInitialFetch.has(threadId);\n}\n\nexport function clearSkipInitialFetch(state: BakendState, threadId: string) {\n  state.skipInitialFetch.delete(threadId);\n}\n\nexport function setSessionRunning(state: BakendState, threadId: string, running: boolean) {\n  if (running) {\n    state.runningSessions.add(threadId);\n  } else {\n    state.runningSessions.delete(threadId);\n  }\n}\n\nexport function getRunningSessions(state: BakendState): string[] {\n  return Array.from(state.runningSessions);\n}\n\nexport function isSessionRunning(state: BakendState, threadId: string): boolean {\n  return state.runningSessions.has(threadId);\n}\n\nexport function enqueuePendingSession(state: BakendState, threadId: string, text: string) {\n  const existing = state.pendingSession.get(threadId) ?? [];\n  state.pendingSession.set(threadId, [...existing, text]);\n}\n\nexport function dequeuePendingSession(state: BakendState, threadId: string): string[] {\n  const pending = state.pendingSession.get(threadId) ?? [];\n  state.pendingSession.delete(threadId);\n  return pending;\n}\n\nexport function hasPendingSession(state: BakendState, threadId: string): boolean {\n  return (state.pendingSession.get(threadId)?.length ?? 0) > 0;\n}\n\nexport function enqueuePendingSystem(state: BakendState, threadId: string, text: string) {\n  const existing = state.pendingSystem.get(threadId) ?? [];\n  state.pendingSystem.set(threadId, [...existing, text]);\n}\n\nexport function dequeuePendingSystem(state: BakendState, threadId: string): string[] {\n  const pending = state.pendingSystem.get(threadId) ?? [];\n  state.pendingSystem.delete(threadId);\n  return pending;\n}\n\nexport function hasPendingSystem(state: BakendState, threadId: string): boolean {\n  return (state.pendingSystem.get(threadId)?.length ?? 0) > 0;\n}\n","import type { MutableRefObject } from \"react\";\nimport type { AppendMessage, ThreadMessageLike } from \"@assistant-ui/react\";\n\nimport type { BackendApi } from \"../api/client\";\nimport type { SessionMessage } from \"../api/types\";\nimport { toInboundSystem, toInboundMessage } from \"../utils/conversion\";\nimport type { ThreadContext } from \"../state/thread-store\";\nimport type { PollingController } from \"./polling-controller\";\nimport {\n  dequeuePendingSession,\n  dequeuePendingSystem,\n  enqueuePendingSession,\n  enqueuePendingSystem,\n  hasPendingSession,\n  isSessionReady,\n  resolveSessionId,\n  setSessionRunning,\n  type BakendState,\n} from \"./backend-state\";\n\ntype MessageConverterConfig = {\n  backendApiRef: MutableRefObject<BackendApi>;\n  backendStateRef: MutableRefObject<BakendState>;\n  threadContextRef: MutableRefObject<ThreadContext>;\n  polling: PollingController;\n  setGlobalIsRunning?: (running: boolean) => void;\n};\n\n// Singleton processor interface, stateless\nexport class MessageConverter {\n  constructor(private readonly config: MessageConverterConfig) {}\n\n  inbound(threadId: string, msgs?: SessionMessage[] | null) {\n    const backendState = this.config.backendStateRef.current;\n    if (!msgs) return;\n    if (hasPendingSession(backendState, threadId)) {\n      // Avoid overwriting optimistic UI when pending user messages exist.\n      return;\n    }\n\n    const threadMessages: ThreadMessageLike[] = [];\n    for (const msg of msgs) {\n      if (msg.sender === \"system\") {\n        const systemMessage = toInboundSystem(msg);\n        if (systemMessage) {\n          threadMessages.push(systemMessage);\n        }\n        continue;\n      }\n      const threadMessage = toInboundMessage(msg);\n      if (threadMessage) {\n        threadMessages.push(threadMessage);\n      }\n    }\n\n    this.config.threadContextRef.current.setThreadMessages(threadId, threadMessages);\n  }\n\n  async outbound(message: AppendMessage, threadId: string) {\n    const backendState = this.config.backendStateRef.current;\n    const text = message.content\n      .filter((part): part is Extract<typeof part, { type: \"text\" }> => part.type === \"text\")\n      .map((part: Extract<typeof message.content[number], { type: \"text\" }>) => part.text)\n      .join(\"\\n\");\n\n    if (!text) return;\n\n    const threadContext = this.config.threadContextRef.current;\n    const existingMessages = threadContext.getThreadMessages(threadId);\n    const userMessage: ThreadMessageLike = {\n      role: \"user\",\n      content: [{ type: \"text\", text }],\n      createdAt: new Date(),\n    };\n\n    threadContext.setThreadMessages(threadId, [...existingMessages, userMessage]);\n    threadContext.updateThreadMetadata(threadId, { lastActiveAt: new Date().toISOString() });\n\n    if (!isSessionReady(backendState, threadId)) {\n      this.markRunning(threadId, true);\n      enqueuePendingSession(backendState, threadId, text);\n      return;\n    }\n\n    const sessionId = resolveSessionId(backendState, threadId);\n\n    try {\n      this.markRunning(threadId, true);\n      await this.config.backendApiRef.current.postChatMessage(sessionId, text);\n      await this.flushPendingSystem(threadId);\n      this.config.polling.start(threadId);\n    } catch (error) {\n      console.error(\"Failed to send message:\", error);\n      this.markRunning(threadId, false);\n    }\n  }\n\n  async outboundSystem(threadId: string, text: string) {\n    const backendState = this.config.backendStateRef.current;\n    if (!isSessionReady(backendState, threadId)) return;\n    const threadMessages = this.config.threadContextRef.current.getThreadMessages(threadId);\n    const hasUserMessages = threadMessages.some((msg) => msg.role === \"user\");\n\n    if (!hasUserMessages) {\n      enqueuePendingSystem(backendState, threadId, text);\n      return;\n    }\n\n    await this.outboundSystemInner(threadId, text);\n  }\n\n  async outboundSystemInner(threadId: string, text: string) {\n    const backendState = this.config.backendStateRef.current;\n    const threadContext = this.config.threadContextRef.current;\n    const sessionId = resolveSessionId(backendState, threadId);\n    this.markRunning(threadId, true);\n    try {\n      const response = await this.config.backendApiRef.current.postSystemMessage(sessionId, text);\n      if (response.res) {\n        const systemMessage = toInboundSystem(response.res);\n        if (systemMessage) {\n          const updatedMessages = [...threadContext.getThreadMessages(threadId), systemMessage];\n          threadContext.setThreadMessages(threadId, updatedMessages);\n        }\n      }\n      await this.flushPendingSystem(threadId);\n      this.config.polling.start(threadId);\n    } catch (error) {\n      console.error(\"Failed to send system message:\", error);\n      this.markRunning(threadId, false);\n    }\n  }\n\n  async flushPendingSystem(threadId: string) {\n    const backendState = this.config.backendStateRef.current;\n    const pending = dequeuePendingSystem(backendState, threadId);\n    if (!pending.length) return;\n    for (const pendingMessage of pending) {\n      await this.outboundSystemInner(threadId, pendingMessage);\n    }\n  }\n\n  async flushPendingSession(threadId: string) {\n    const backendState = this.config.backendStateRef.current;\n    const pending = dequeuePendingSession(backendState, threadId);\n    if (!pending.length) return;\n    const sessionId = resolveSessionId(backendState, threadId);\n    for (const text of pending) {\n      try {\n        await this.config.backendApiRef.current.postChatMessage(sessionId, text);\n      } catch (error) {\n        console.error(\"Failed to send queued message:\", error);\n      }\n    }\n    this.config.polling.start(threadId);\n  }\n\n  async cancel(threadId: string) {\n    const backendState = this.config.backendStateRef.current;\n    if (!isSessionReady(backendState, threadId)) return;\n    this.config.polling.stop(threadId);\n    const sessionId = resolveSessionId(backendState, threadId);\n    try {\n      await this.config.backendApiRef.current.postInterrupt(sessionId);\n      this.markRunning(threadId, false);\n    } catch (error) {\n      console.error(\"Failed to cancel:\", error);\n    }\n  }\n\n  private markRunning(threadId: string, running: boolean) {\n    setSessionRunning(this.config.backendStateRef.current, threadId, running);\n    if (this.config.threadContextRef.current.currentThreadId === threadId) {\n      this.config.setGlobalIsRunning?.(running);\n    }\n  }\n\n}\n","import type { MutableRefObject } from \"react\";\n\nimport type { BackendApi } from \"../api/client\";\nimport type { SessionMessage, SessionResponsePayload } from \"../api/types\";\nimport {\n  isSessionReady,\n  resolveSessionId,\n  setSessionRunning,\n  type BakendState,\n} from \"./backend-state\";\n\ntype PollingConfig = {\n  backendApiRef: MutableRefObject<BackendApi>;\n  backendStateRef: MutableRefObject<BakendState>;\n  applyMessages: (threadId: string, messages?: SessionMessage[] | null) => void;\n  onStop?: (threadId: string) => void;\n  intervalMs?: number;\n};\n\n// Singleton stateful poller, keep a map of threadId -> intervalId\nexport class PollingController {\n  private intervals = new Map<string, ReturnType<typeof setInterval>>();\n  private intervalMs: number;\n\n  constructor(private readonly config: PollingConfig) {\n    this.intervalMs = config.intervalMs ?? 500;\n  }\n\n  start(threadId: string) {\n    const backendState = this.config.backendStateRef.current;\n    if (!isSessionReady(backendState, threadId)) return;\n    if (this.intervals.has(threadId)) return;\n\n    const sessionId = resolveSessionId(backendState, threadId);\n    setSessionRunning(backendState, threadId, true);\n\n    const tick = async () => {\n      try {\n        const state = await this.config.backendApiRef.current.fetchState(sessionId);\n        this.handleState(threadId, state);\n      } catch (error) {\n        console.error(\"Polling error:\", error);\n        this.stop(threadId);\n      }\n    };\n\n    const intervalId = setInterval(tick, this.intervalMs);\n    this.intervals.set(threadId, intervalId);\n  }\n\n  stop(threadId: string) {\n    const intervalId = this.intervals.get(threadId);\n    if (intervalId) {\n      clearInterval(intervalId);\n      this.intervals.delete(threadId);\n    }\n    setSessionRunning(this.config.backendStateRef.current, threadId, false);\n    this.config.onStop?.(threadId);\n  }\n\n  stopAll() {\n    for (const threadId of this.intervals.keys()) {\n      this.stop(threadId);\n    }\n  }\n\n  private handleState(threadId: string, state: SessionResponsePayload) {\n    if (state.session_exists === false) {\n      this.stop(threadId);\n      return;\n    }\n\n    this.config.applyMessages(threadId, state.messages);\n\n    if (!state.is_processing) {\n      this.stop(threadId);\n    }\n  }\n}\n","\"use client\";\n\nimport { useCallback, useMemo } from \"react\";\nimport type { MutableRefObject } from \"react\";\nimport type { ExternalStoreThreadData as AuiThreadData } from \"@assistant-ui/react\";\n\nimport {\n  skipFirstFetch,\n  setBackendMapping,\n  type BakendState,\n} from \"./backend-state\";\nimport { isPlaceholderTitle, parseTimestamp } from \"./utils\";\nimport type { PollingController } from \"./polling-controller\";\nimport type { BackendApi } from \"../api/client\";\nimport type { ThreadContext } from \"../state/thread-store\";\nimport type { ThreadMetadata } from \"../state/types\";\n\nconst sortByLastActiveDesc = (\n  [, metaA]: [string, ThreadMetadata],\n  [, metaB]: [string, ThreadMetadata]\n) => {\n  const tsA = parseTimestamp(metaA.lastActiveAt);\n  const tsB = parseTimestamp(metaB.lastActiveAt);\n  return tsB - tsA;\n};\n\nconst DEFAULT_THREAD_TITLE = \"New Chat\";\nconst DEFAULT_SESSION_ID = \"default-session\";\n\nfunction buildThreadLists(threadMetadata: Map<string, ThreadMetadata>) {\n  const entries = Array.from(threadMetadata.entries()).filter(\n    ([, meta]) => !isPlaceholderTitle(meta.title)\n  );\n\n  const auiRegularThreads = entries\n    .filter(([, meta]) => meta.status === \"regular\")\n    .sort(sortByLastActiveDesc)\n    .map(([id, meta]): AuiThreadData<\"regular\"> => ({\n      id,\n      title: meta.title || DEFAULT_THREAD_TITLE,\n      status: \"regular\",\n    }));\n\n  const auiArchivedThreads = entries\n    .filter(([, meta]) => meta.status === \"archived\")\n    .sort(sortByLastActiveDesc)\n    .map(([id, meta]): AuiThreadData<\"archived\"> => ({\n      id,\n      title: meta.title || DEFAULT_THREAD_TITLE,\n      status: \"archived\",\n    }));\n\n  return { auiThreads: auiRegularThreads, auiArchivedThreads };\n}\n\nfunction deleteThreadFromContext(context: ThreadContext, threadId: string) {\n  context.setThreadMetadata((prev) => {\n    const next = new Map(prev);\n    next.delete(threadId);\n    return next;\n  });\n  context.setThreads((prev) => {\n    const next = new Map(prev);\n    next.delete(threadId);\n    return next;\n  });\n}\n\nfunction clearPendingQueues(backendState: BakendState, threadId: string) {\n  backendState.pendingSession.delete(threadId);\n  backendState.pendingSystem.delete(threadId);\n}\n\nfunction clearPendingThreadState(backendState: BakendState, threadId: string) {\n  clearPendingQueues(backendState, threadId);\n  backendState.tempToSessionId.delete(threadId);\n  backendState.skipInitialFetch.delete(threadId);\n}\n\nfunction updateTitleFromBackend(\n  context: ThreadContext,\n  threadId: string,\n  backendTitle?: string | null\n) {\n  if (!backendTitle || isPlaceholderTitle(backendTitle)) return;\n\n  context.setThreadMetadata((prev) => {\n    const next = new Map(prev);\n    const existing = next.get(threadId);\n    const nextStatus = existing?.status === \"archived\" ? \"archived\" : \"regular\";\n    next.set(threadId, {\n      title: backendTitle,\n      status: nextStatus,\n      lastActiveAt: existing?.lastActiveAt ?? new Date().toISOString(),\n    });\n    return next;\n  });\n}\n\nfunction ensureFallbackThread(context: ThreadContext, removedId: string) {\n  if (context.currentThreadId !== removedId) return;\n\n  const firstRegularThread = Array.from(context.threadMetadata.entries()).find(\n    ([id, meta]) => meta.status === \"regular\" && id !== removedId\n  );\n\n  if (firstRegularThread) {\n    context.setCurrentThreadId(firstRegularThread[0]);\n    return;\n  }\n\n  context.setThreadMetadata((prev) =>\n    new Map(prev).set(DEFAULT_SESSION_ID, {\n      title: DEFAULT_THREAD_TITLE,\n      status: \"regular\",\n      lastActiveAt: new Date().toISOString(),\n    })\n  );\n  context.setThreadMessages(DEFAULT_SESSION_ID, []);\n  context.setCurrentThreadId(DEFAULT_SESSION_ID);\n}\n\ntype ThreadListAdapterParams = {\n  backendApiRef: MutableRefObject<BackendApi>;\n  backendStateRef: MutableRefObject<BakendState>;\n  currentThreadIdRef: MutableRefObject<string>;\n  polling: PollingController;\n  publicKey?: string;\n  setIsRunning: (running: boolean) => void;\n  threadContext: ThreadContext;\n  threadContextRef: MutableRefObject<ThreadContext>;\n};\n\n// Data transformation (for rendering):\n//     Uses buildThreadLists to convert internal state â†’ AUI format\n// Action handlers (for user interactions):\n//     builds callbacks that coordinate threadContext and backendState\nexport type ThreadListAdapter = {\n  threadId: string;\n  auiThreads: AuiThreadData<\"regular\">[];\n  auiArchivedThreads: AuiThreadData<\"archived\">[];\n  onSwitchToNewThread: () => Promise<void>;\n  onSwitchToThread: (threadId: string) => void;\n  onRename: (threadId: string, newTitle: string) => Promise<void>;\n  onArchive: (threadId: string) => Promise<void>;\n  onUnarchive: (threadId: string) => Promise<void>;\n  onDelete: (threadId: string) => Promise<void>;\n};\n\nexport function useThreadListAdapter({\n  backendApiRef,\n  backendStateRef,\n  currentThreadIdRef,\n  polling,\n  publicKey,\n  setIsRunning,\n  threadContext,\n  threadContextRef,\n}: ThreadListAdapterParams): ThreadListAdapter {\n\n  // adapt to AUI data format and cache it with useMemo\n  // auiRegularThreads [{id, title, 'regular'}, ...]\n  // auiArchivedThreads [{id, title, 'archived'}, ...]\n\n  const { auiThreads, auiArchivedThreads } = useMemo(\n    // UI action â†’ updateThreadMetadata â†’ updateState â†’ new snapshot created â†’ emit() \n    // â†’ useSyncExternalStore detects change â†’ getSnapshot() returns new ThreadContext \n    // â†’ component re-renders â†’ [threadContext.threadMetadata] dependency changes \n    () => buildThreadLists(threadContext.threadMetadata),\n    [threadContext.threadMetadata]\n  );\n\n  const removePendingThread = useCallback(\n    (threadId: string) => {\n      const currentContext = threadContextRef.current;\n      deleteThreadFromContext(currentContext, threadId);\n      clearPendingThreadState(backendStateRef.current, threadId);\n    },\n    [backendStateRef, threadContextRef]\n  );\n\n  const preparePendingThread = useCallback(\n    (threadId: string) => {\n      const backendState = backendStateRef.current;\n      const previousPendingId = backendState.creatingThreadId;\n      if (previousPendingId && previousPendingId !== threadId) {\n        removePendingThread(previousPendingId);\n      }\n      backendState.creatingThreadId = threadId;\n      clearPendingQueues(backendState, threadId);\n      const currentContext = threadContextRef.current;\n      currentContext.setThreadMetadata((prev) =>\n        new Map(prev).set(threadId, {\n          title: DEFAULT_THREAD_TITLE,\n          status: \"pending\",\n          lastActiveAt: new Date().toISOString(),\n        })\n      );\n      currentContext.setThreadMessages(threadId, []);\n      currentContext.setCurrentThreadId(threadId);\n      setIsRunning(false);\n      currentContext.bumpThreadViewKey();\n    },\n    [backendStateRef, removePendingThread, setIsRunning, threadContextRef]\n  );\n\n  const findPendingThreadId = useCallback(() => {\n    const backendState = backendStateRef.current;\n    if (backendState.creatingThreadId) return backendState.creatingThreadId;\n    for (const [id, meta] of threadContextRef.current.threadMetadata.entries()) {\n      if (meta.status === \"pending\") return id;\n    }\n    return null;\n  }, [backendStateRef, threadContextRef]);\n\n  const onSwitchToNewThread = useCallback(async () => {\n    const backendState = backendStateRef.current;\n    const pendingId = findPendingThreadId();\n    if (pendingId) {\n      preparePendingThread(pendingId);\n      return;\n    }\n\n    if (backendState.createThreadPromise) {\n      preparePendingThread(backendState.creatingThreadId ?? `temp-${crypto.randomUUID()}`);\n      return;\n    }\n\n    const tempId = `temp-${crypto.randomUUID()}`;\n    preparePendingThread(tempId);\n\n    const createPromise = backendApiRef.current\n      .createThread(publicKey, undefined)\n      .then(async (newThread) => {\n        const uiThreadId = backendState.creatingThreadId ?? tempId;\n        const backendId = newThread.session_id;\n\n        setBackendMapping(backendState, uiThreadId, backendId);\n        skipFirstFetch(backendState, uiThreadId);\n\n        updateTitleFromBackend(threadContextRef.current, uiThreadId, newThread.title);\n\n        if (backendState.creatingThreadId === uiThreadId) {\n          backendState.creatingThreadId = null;\n        }\n\n        const pendingMessages = backendState.pendingSession.get(uiThreadId);\n        if (pendingMessages?.length) {\n          backendState.pendingSession.delete(uiThreadId);\n          for (const text of pendingMessages) {\n            try {\n              await backendApiRef.current.postChatMessage(backendId, text);\n            } catch (error) {\n              console.error(\"Failed to send queued message:\", error);\n            }\n          }\n          if (currentThreadIdRef.current === uiThreadId) {\n            polling?.start(uiThreadId);\n          }\n        }\n      })\n      .catch((error) => {\n        console.error(\"Failed to create new thread:\", error);\n        const failedId = backendState.creatingThreadId ?? tempId;\n        deleteThreadFromContext(threadContextRef.current, failedId);\n        if (backendState.creatingThreadId === failedId) {\n          backendState.creatingThreadId = null;\n        }\n      })\n      .finally(() => {\n        backendState.createThreadPromise = null;\n      });\n\n    backendState.createThreadPromise = createPromise;\n  }, [\n    backendApiRef,\n    backendStateRef,\n    currentThreadIdRef,\n    findPendingThreadId,\n    polling,\n    preparePendingThread,\n    publicKey,\n    threadContextRef,\n  ]);\n\n  const onSwitchToThread = useCallback(\n    (threadId: string) => {\n      threadContextRef.current.setCurrentThreadId(threadId);\n    },\n    [threadContextRef]\n  );\n\n  const onRename = useCallback(\n    async (threadId: string, newTitle: string) => {\n      const currentContext = threadContextRef.current;\n      const previousTitle = currentContext.getThreadMetadata(threadId)?.title ?? \"\";\n      const normalizedTitle = isPlaceholderTitle(newTitle) ? \"\" : newTitle;\n      currentContext.updateThreadMetadata(threadId, {\n        title: normalizedTitle,\n      });\n\n      try {\n        await backendApiRef.current.renameThread(threadId, newTitle);\n      } catch (error) {\n        console.error(\"Failed to rename thread:\", error);\n        currentContext.updateThreadMetadata(threadId, { title: previousTitle });\n      }\n    },\n    [backendApiRef, threadContextRef]\n  );\n\n  const onArchive = useCallback(\n    async (threadId: string) => {\n      const currentContext = threadContextRef.current;\n      currentContext.updateThreadMetadata(threadId, { status: \"archived\" });\n\n      try {\n        await backendApiRef.current.archiveThread(threadId);\n      } catch (error) {\n        console.error(\"Failed to archive thread:\", error);\n        currentContext.updateThreadMetadata(threadId, { status: \"regular\" });\n      }\n    },\n    [backendApiRef, threadContextRef]\n  );\n\n  const onUnarchive = useCallback(\n    async (threadId: string) => {\n      const currentContext = threadContextRef.current;\n      currentContext.updateThreadMetadata(threadId, { status: \"regular\" });\n\n      try {\n        await backendApiRef.current.unarchiveThread(threadId);\n      } catch (error) {\n        console.error(\"Failed to unarchive thread:\", error);\n        currentContext.updateThreadMetadata(threadId, { status: \"archived\" });\n      }\n    },\n    [backendApiRef, threadContextRef]\n  );\n\n  const onDelete = useCallback(\n    async (threadId: string) => {\n      try {\n        await backendApiRef.current.deleteThread(threadId);\n\n        const currentContext = threadContextRef.current;\n        deleteThreadFromContext(currentContext, threadId);\n        const backendState = backendStateRef.current;\n        clearPendingThreadState(backendState, threadId);\n        backendState.runningSessions.delete(threadId);\n        if (backendState.creatingThreadId === threadId) {\n          backendState.creatingThreadId = null;\n        }\n\n        ensureFallbackThread(currentContext, threadId);\n      } catch (error) {\n        console.error(\"Failed to delete thread:\", error);\n        throw error;\n      }\n    },\n    [backendApiRef, backendStateRef, threadContextRef]\n  );\n\n  return useMemo<ThreadListAdapter>(\n    () => ({\n      threadId: threadContext.currentThreadId,\n      auiThreads,\n      auiArchivedThreads,\n      onSwitchToNewThread,\n      onSwitchToThread,\n      onRename,\n      onArchive,\n      onUnarchive,\n      onDelete,\n    }),\n    [\n      auiArchivedThreads,\n      onArchive,\n      onDelete,\n      onRename,\n      onSwitchToNewThread,\n      onSwitchToThread,\n      onUnarchive,\n      auiThreads,\n      threadContext.currentThreadId,\n    ]\n  );\n}\n\nexport async function fetchPubkeyThreads(\n  publicKey: string,\n  backendApiRef: MutableRefObject<BackendApi>,\n  threadContextRef: MutableRefObject<ThreadContext>\n) {\n  try {\n    const threadList = await backendApiRef.current.fetchThreads(publicKey);\n    const currentContext = threadContextRef.current;\n    const newMetadata = new Map(currentContext.threadMetadata);\n    let maxChatNum = currentContext.threadCnt;\n\n    for (const thread of threadList) {\n      const rawTitle = thread.title ?? \"\";\n      const title = isPlaceholderTitle(rawTitle) ? \"\" : rawTitle;\n      const lastActive =\n        thread.last_active_at ||\n        thread.updated_at ||\n        thread.created_at ||\n        newMetadata.get(thread.session_id)?.lastActiveAt ||\n        new Date().toISOString();\n      newMetadata.set(thread.session_id, {\n        title,\n        status: thread.is_archived ? \"archived\" : \"regular\",\n        lastActiveAt: lastActive,\n      });\n\n      const match = title.match(/^Chat (\\d+)$/);\n      if (match) {\n        const num = parseInt(match[1], 10);\n        if (num > maxChatNum) {\n          maxChatNum = num;\n        }\n      }\n    }\n\n    currentContext.setThreadMetadata(newMetadata);\n    if (maxChatNum > currentContext.threadCnt) {\n      currentContext.setThreadCnt(maxChatNum);\n    }\n  } catch (error) {\n    console.error(\"Failed to fetch thread list:\", error);\n  }\n}\n","\"use client\";\n\nimport { createContext, useContext, useMemo, useRef, useSyncExternalStore } from \"react\";\nimport type { ReactNode } from \"react\";\nimport type { ThreadMessageLike } from \"@assistant-ui/react\";\n\nimport type { ThreadMetadata } from \"./types\";\nimport { ThreadStore, type ThreadContext } from \"./thread-store\";\n\nexport type ThreadContextProviderProps = {\n  children: ReactNode;\n  initialThreadId?: string;\n};\n\nconst ThreadContextState = createContext<ThreadContext | null>(null);\n\nexport function useThreadContext(): ThreadContext {\n  // Initialization: \n  // ThreadContextProvider      // new ThreadStore({ initialThreadId }) \n  //  -> ThreadStore            // this.createSnapshot();\n  //  -> ThreadContext\n\n  // useContext only peek into the in-DOM context after construction\n  const context = useContext(ThreadContextState);\n  if (!context) {\n    throw new Error(\n      \"useThreadContext must be used within ThreadContextProvider. \" +\n        \"Wrap your app with <ThreadContextProvider>...</ThreadContextProvider>\"\n    );\n  }\n  return context;\n}\n\nexport function ThreadContextProvider({\n  children,\n  initialThreadId,\n}: ThreadContextProviderProps) {\n  // Alloc the ThreadStore state\n  const storeRef = useRef<ThreadStore | null>(null);\n  if (!storeRef.current) {\n    // Init \n    storeRef.current = new ThreadStore({ initialThreadId });\n  }\n  // Get the ThreadStore state from useRef smart pointer\n  const store = storeRef.current;\n\n  // React 18+ hook for wiring an external store to Reactâ€™s render cycle\n  // store.subscribe tells React ThreadStore has changed\n  // store.getSnapshot returns the current ThreadStore state\n  // value is whatever store.getSnapshot() returns, before that React re-renders the component to sync data\n  const value = useSyncExternalStore(store.subscribe, store.getSnapshot);\n\n  return (\n    // Feed the sync value of ThreadStore to child components\n    <ThreadContextState.Provider value={value}>{children}</ThreadContextState.Provider>\n  );\n}\n\nexport function useCurrentThreadMessages(): ThreadMessageLike[] {\n  const { currentThreadId, getThreadMessages } = useThreadContext();\n  return useMemo(() => getThreadMessages(currentThreadId), [currentThreadId, getThreadMessages]);\n}\n\nexport function useCurrentThreadMetadata(): ThreadMetadata | undefined {\n  const { currentThreadId, getThreadMetadata } = useThreadContext();\n  return useMemo(() => getThreadMetadata(currentThreadId), [currentThreadId, getThreadMetadata]);\n}\n","import type { SetStateAction } from \"react\";\nimport type { ThreadMessageLike } from \"@assistant-ui/react\";\n\nimport type { ThreadMetadata } from \"./types\";\n\n// Contextural state of the UI thread (what user sees)\nexport type ThreadContext = {\n  currentThreadId: string;\n  setCurrentThreadId: (id: string) => void;\n  threadViewKey: number;\n  bumpThreadViewKey: () => void;\n  threads: Map<string, ThreadMessageLike[]>;\n  setThreads: (updater: SetStateAction<Map<string, ThreadMessageLike[]>>) => void;\n  threadMetadata: Map<string, ThreadMetadata>;\n  setThreadMetadata: (updater: SetStateAction<Map<string, ThreadMetadata>>) => void;\n  threadCnt: number;\n  setThreadCnt: (updater: SetStateAction<number>) => void;\n  getThreadMessages: (threadId: string) => ThreadMessageLike[];\n  setThreadMessages: (threadId: string, messages: ThreadMessageLike[]) => void;\n  getThreadMetadata: (threadId: string) => ThreadMetadata | undefined;\n  updateThreadMetadata: (threadId: string, updates: Partial<ThreadMetadata>) => void;\n};\n\ntype ThreadStoreState = {\n  currentThreadId: string;\n  threadViewKey: number;\n  threadCnt: number;\n  threads: Map<string, ThreadMessageLike[]>;\n  threadMetadata: Map<string, ThreadMetadata>;\n};\n\ntype ThreadStoreOptions = {\n  initialThreadId?: string;\n};\n\nexport class ThreadStore {\n  private state: ThreadStoreState;\n  private snapshot: ThreadContext;\n  private listeners = new Set<() => void>();\n\n  constructor(options?: ThreadStoreOptions) {\n    const initialThreadId = options?.initialThreadId ?? crypto.randomUUID();\n    this.state = {\n      currentThreadId: initialThreadId,\n      threadViewKey: 0,\n      threadCnt: 1,\n      threads: new Map([[initialThreadId, []]]),\n      threadMetadata: new Map([\n        [\n          initialThreadId,\n          {\n            title: \"New Chat\",\n            status: \"pending\",\n            lastActiveAt: new Date().toISOString(),\n          },\n        ],\n      ]),\n    };\n    this.snapshot = this.createSnapshot();\n  }\n\n  subscribe = (listener: () => void): (() => void) => {\n    this.listeners.add(listener);\n    return () => {\n      this.listeners.delete(listener);\n    };\n  };\n\n  getSnapshot = (): ThreadContext => this.snapshot;\n\n  private createSnapshot(): ThreadContext {\n    return {\n      currentThreadId: this.state.currentThreadId,\n      setCurrentThreadId: this.setCurrentThreadId,\n      threadViewKey: this.state.threadViewKey,\n      bumpThreadViewKey: this.bumpThreadViewKey,\n      threads: this.state.threads,\n      setThreads: this.setThreads,\n      threadMetadata: this.state.threadMetadata,\n      setThreadMetadata: this.setThreadMetadata,\n      threadCnt: this.state.threadCnt,\n      setThreadCnt: this.setThreadCnt,\n      getThreadMessages: this.getThreadMessages,\n      setThreadMessages: this.setThreadMessages,\n      getThreadMetadata: this.getThreadMetadata,\n      updateThreadMetadata: this.updateThreadMetadata,\n    };\n  }\n\n  private emit() {\n    for (const listener of this.listeners) {\n      listener();\n    }\n  }\n\n  private resolveStateAction<T>(updater: SetStateAction<T>, current: T): T {\n    return typeof updater === \"function\" ? (updater as (prev: T) => T)(current) : updater;\n  }\n\n  private ensureThreadExists(threadId: string) {\n    if (!this.state.threadMetadata.has(threadId)) {\n      const nextMetadata = new Map(this.state.threadMetadata);\n      nextMetadata.set(threadId, {\n        title: \"New Chat\",\n        status: \"regular\",\n        lastActiveAt: new Date().toISOString(),\n      });\n      this.state = { ...this.state, threadMetadata: nextMetadata };\n    }\n\n    if (!this.state.threads.has(threadId)) {\n      const nextThreads = new Map(this.state.threads);\n      nextThreads.set(threadId, []);\n      this.state = { ...this.state, threads: nextThreads };\n    }\n  }\n\n  private updateState(partial: Partial<ThreadStoreState>) {\n    this.state = { ...this.state, ...partial };\n    this.snapshot = this.createSnapshot();\n    this.emit();\n  }\n\n  setCurrentThreadId = (threadId: string) => {\n    this.ensureThreadExists(threadId);\n    this.updateState({ currentThreadId: threadId });\n  };\n\n  bumpThreadViewKey = () => {\n    this.updateState({ threadViewKey: this.state.threadViewKey + 1 });\n  };\n\n  setThreadCnt = (updater: SetStateAction<number>) => {\n    const nextCnt = this.resolveStateAction(updater, this.state.threadCnt);\n    this.updateState({ threadCnt: nextCnt });\n  };\n\n  setThreads = (updater: SetStateAction<Map<string, ThreadMessageLike[]>>) => {\n    const nextThreads = this.resolveStateAction(updater, this.state.threads);\n    this.updateState({ threads: new Map(nextThreads) });\n  };\n\n  setThreadMetadata = (updater: SetStateAction<Map<string, ThreadMetadata>>) => {\n    const nextMetadata = this.resolveStateAction(updater, this.state.threadMetadata);\n    this.updateState({ threadMetadata: new Map(nextMetadata) });\n  };\n\n  setThreadMessages = (threadId: string, messages: ThreadMessageLike[]) => {\n    this.ensureThreadExists(threadId);\n    const nextThreads = new Map(this.state.threads);\n    nextThreads.set(threadId, messages);\n    this.updateState({ threads: nextThreads });\n  };\n\n  getThreadMessages = (threadId: string): ThreadMessageLike[] => {\n    return this.state.threads.get(threadId) ?? [];\n  };\n\n  getThreadMetadata = (threadId: string): ThreadMetadata | undefined => {\n    return this.state.threadMetadata.get(threadId);\n  };\n\n  getAllMetadatas = (): ThreadMetadata[] => {\n    return Array.from(this.state.threadMetadata.values());\n  };\n\n  getAllThreads = (): Map<string, ThreadMessageLike[]> => {\n    return this.state.threads;\n  };\n\n  updateThreadMetadata = (threadId: string, updates: Partial<ThreadMetadata>) => {\n    const existing = this.state.threadMetadata.get(threadId);\n    if (!existing) {\n      return;\n    }\n    const nextMetadata = new Map(this.state.threadMetadata);\n    nextMetadata.set(threadId, { ...existing, ...updates });\n    this.updateState({ threadMetadata: nextMetadata });\n  };\n}\n","\"use client\";\n\nimport { useEffect, useRef } from \"react\";\n\nimport { useRuntimeActions } from \"../runtime/hooks\";\n\nexport type WalletButtonState = {\n  address?: string;\n  chainId?: number;\n  isConnected: boolean;\n  ensName?: string;\n};\n\nexport type WalletFooterProps = {\n  wallet: WalletButtonState;\n  setWallet: (data: Partial<WalletButtonState>) => void;\n};\n\nexport const getNetworkName = (chainId: number | string | undefined): string => {\n  if (chainId === undefined) return \"\";\n  const id = typeof chainId === \"string\" ? Number(chainId) : chainId;\n  switch (id) {\n    case 1:\n      return \"ethereum\";\n    case 137:\n      return \"polygon\";\n    case 42161:\n      return \"arbitrum\";\n    case 8453:\n      return \"base\";\n    case 10:\n      return \"optimism\";\n    case 11155111:\n      return \"sepolia\";\n    case 1337:\n    case 31337:\n      return \"testnet\";\n    case 59140:\n      return \"linea-sepolia\";\n    case 59144:\n      return \"linea\";\n    default:\n      return \"testnet\";\n  }\n};\n\nexport const formatAddress = (addr?: string): string =>\n  addr ? `${addr.slice(0, 6)}...${addr.slice(-4)}` : \"Connect Wallet\";\n\ntype WalletSystemMessageEmitterProps = {\n  wallet: WalletButtonState;\n};\n\nexport function WalletSystemMessageEmitter({ wallet }: WalletSystemMessageEmitterProps) {\n  const { sendSystemMessage } = useRuntimeActions();\n  const lastWalletRef = useRef<{\n    isConnected: boolean;\n    address?: string;\n    chainId?: number;\n  }>({ isConnected: false });\n\n  useEffect(() => {\n    const prev = lastWalletRef.current;\n    const { address, chainId, isConnected } = wallet;\n    const normalizedAddress = address?.toLowerCase();\n\n    if (\n      isConnected &&\n      normalizedAddress &&\n      chainId &&\n      (!prev.isConnected || prev.address !== normalizedAddress)\n    ) {\n      const networkName = getNetworkName(chainId);\n      const message = `User connected wallet with address ${normalizedAddress} on ${networkName} network (Chain ID: ${chainId}). Ready to help with transactions.`;\n      console.log(message);\n      void sendSystemMessage(message);\n      lastWalletRef.current = { isConnected: true, address: normalizedAddress, chainId };\n      return;\n    }\n\n    if (!isConnected && prev.isConnected) {\n      void sendSystemMessage(\"Wallet disconnected by user.\");\n      console.log(\"Wallet disconnected by user.\");\n      lastWalletRef.current = { isConnected: false };\n      return;\n    }\n\n    if (\n      isConnected &&\n      normalizedAddress &&\n      chainId &&\n      prev.isConnected &&\n      prev.address === normalizedAddress &&\n      prev.chainId !== chainId\n    ) {\n      const networkName = getNetworkName(chainId);\n      const message = `User switched wallet to ${networkName} network (Chain ID: ${chainId}).`;\n      console.log(message);\n      void sendSystemMessage(message);\n      lastWalletRef.current = { isConnected: true, address: normalizedAddress, chainId };\n    }\n  }, [wallet, sendSystemMessage]);\n\n  return null;\n}\n","import { clsx, type ClassValue } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n"],"mappings":"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","names":["import_react","import_react","parseTimestamp","import_react","parseTimestamp","_a","import_react","import_jsx_runtime","_a","import_react"]}