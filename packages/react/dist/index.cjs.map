{"version":3,"sources":["../src/index.ts","../src/api/client.ts","../src/runtime/aomi-runtime.tsx","../src/utils/conversion.ts","../src/runtime/message-handlers.ts","../src/runtime/polling.ts","../src/runtime/utils.ts","../src/runtime/thread-list-adapter.ts","../src/runtime/hooks.ts","../src/state/thread-context.tsx","../src/utils/wallet.ts","../src/lib/utils.ts"],"sourcesContent":["export { BackendApi } from \"./api/client\";\nexport type {\n  BackendSessionResponse,\n  BackendThreadMetadata,\n  CreateThreadResponse,\n  SessionMessage,\n  SessionResponsePayload,\n  SystemResponsePayload,\n  SystemUpdate,\n} from \"./api/types\";\n\nexport { AomiRuntimeProvider } from \"./runtime/aomi-runtime\";\nexport { useRuntimeActions, RuntimeActionsProvider } from \"./runtime/hooks\";\n\nexport {\n  ThreadContextProvider,\n  useThreadContext,\n  useCurrentThreadMetadata,\n  useCurrentThreadMessages,\n} from \"./state/thread-context\";\nexport type { ThreadMetadata, ThreadStatus } from \"./state/types\";\n\nexport { constructSystemMessage, constructThreadMessage } from \"./utils/conversion\";\nexport { WalletSystemMessageEmitter, formatAddress, getNetworkName } from \"./utils/wallet\";\nexport type { WalletButtonState, WalletFooterProps } from \"./utils/wallet\";\n\nexport { cn } from \"./lib/utils\";\n","import type {\n  BackendSessionResponse,\n  BackendThreadMetadata,\n  CreateThreadResponse,\n  SessionMessage,\n  SessionResponsePayload,\n  SystemResponsePayload,\n  SystemUpdate,\n} from \"./types\";\n\nfunction toQueryString(payload: Record<string, unknown>): string {\n  const params = new URLSearchParams();\n  for (const [key, value] of Object.entries(payload)) {\n    if (value === undefined || value === null) continue;\n    params.set(key, String(value));\n  }\n  const qs = params.toString();\n  return qs ? `?${qs}` : \"\";\n}\n\nasync function postState<T>(\n  backendUrl: string,\n  path: string,\n  payload: Record<string, unknown>\n): Promise<T> {\n  const query = toQueryString(payload);\n  const url = `${backendUrl}${path}${query}`;\n  console.log(\"游댯 [postState] URL:\", url);\n  console.log(\"游댯 [postState] Payload:\", payload);\n\n  const response = await fetch(url, {\n    method: \"POST\",\n  });\n  console.log(\"游댯 [postState] Response status:\", response.status);\n\n  if (!response.ok) {\n    console.error(\"游댮 [postState] Error:\", response.status, response.statusText);\n    throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n  }\n\n  const data = (await response.json()) as T;\n  console.log(\"游릭 [postState] Success:\", data);\n  return data;\n}\n\nexport class BackendApi {\n  private connectionStatus = false;\n  private eventSource: EventSource | null = null;\n  private updatesEventSource: EventSource | null = null;\n\n  constructor(private readonly backendUrl: string) {}\n\n  async fetchState(sessionId: string): Promise<SessionResponsePayload> {\n    console.log(\"游댯 [fetchState] Called with sessionId:\", sessionId);\n    const url = `${this.backendUrl}/api/state?session_id=${encodeURIComponent(sessionId)}`;\n    console.log(\"游댯 [fetchState] URL:\", url);\n\n    const response = await fetch(url);\n    console.log(\"游댯 [fetchState] Response status:\", response.status, response.statusText);\n\n    if (!response.ok) {\n      console.error(\"游댮 [fetchState] Error:\", response.status, response.statusText);\n      throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n    }\n\n    const data = (await response.json()) as SessionResponsePayload;\n    console.log(\"游릭 [fetchState] Success:\", data);\n    return data;\n  }\n\n  async postChatMessage(sessionId: string, message: string): Promise<SessionResponsePayload> {\n    console.log(\"游댯 [postChatMessage] Called with sessionId:\", sessionId, \"message:\", message);\n    const result = await postState<SessionResponsePayload>(this.backendUrl, \"/api/chat\", {\n      message,\n      session_id: sessionId,\n    });\n    console.log(\"游릭 [postChatMessage] Success:\", result);\n    return result;\n  }\n\n  async postSystemMessage(sessionId: string, message: string): Promise<SystemResponsePayload> {\n    console.log(\"游댯 [postSystemMessage] Called with sessionId:\", sessionId, \"message:\", message);\n    const result = await postState<SystemResponsePayload>(this.backendUrl, \"/api/system\", {\n      message,\n      session_id: sessionId,\n    });\n    console.log(\"游릭 [postSystemMessage] Success:\", result);\n    return result;\n  }\n\n  async postInterrupt(sessionId: string): Promise<SessionResponsePayload> {\n    console.log(\"游댯 [postInterrupt] Called with sessionId:\", sessionId);\n    const result = await postState<SessionResponsePayload>(this.backendUrl, \"/api/interrupt\", {\n      session_id: sessionId,\n    });\n    console.log(\"游릭 [postInterrupt] Success:\", result);\n    return result;\n  }\n\n  disconnectSSE(): void {\n    if (this.eventSource) {\n      this.eventSource.close();\n      this.eventSource = null;\n    }\n    this.setConnectionStatus(false);\n  }\n\n  setConnectionStatus(on: boolean): void {\n    this.connectionStatus = on;\n  }\n\n  async connectSSE(sessionId: string, publicKey?: string) {\n    this.disconnectSSE();\n\n    try {\n      const url = new URL(`${this.backendUrl}/api/chat/stream`);\n      url.searchParams.set(\"session_id\", sessionId);\n      if (publicKey) {\n        url.searchParams.set(\"public_key\", publicKey);\n      }\n\n      this.eventSource = new EventSource(url.toString());\n\n      this.eventSource.onopen = () => {\n        console.log(\"游깷 SSE connection opened to:\", url.toString());\n        this.setConnectionStatus(true);\n      };\n\n      this.eventSource.onmessage = (event) => {\n        try {\n          JSON.parse(event.data);\n        } catch (error) {\n          console.error(\"Failed to parse SSE data:\", error);\n        }\n      };\n\n      this.eventSource.onerror = (error) => {\n        console.error(\"SSE connection error:\", error);\n      };\n    } catch (error) {\n      console.error(\"Failed to establish SSE connection:\", error);\n      this.handleConnectionError(sessionId, publicKey);\n    }\n  }\n\n  private handleConnectionError(sessionId: string, publicKey?: string): void {\n    this.setConnectionStatus(false);\n    let attempt = 0;\n    const total = 3;\n    if (attempt < total) {\n      attempt++;\n      console.log(`Attempting to reconnect (${attempt}/${total})...`);\n\n      setTimeout(() => {\n        this.connectSSE(sessionId, publicKey);\n      }, 100);\n    } else {\n      console.error(\"Max reconnection attempts reached\");\n      this.setConnectionStatus(false);\n    }\n  }\n\n  subscribeToUpdates(\n    onUpdate: (update: SystemUpdate) => void,\n    onError?: (error: unknown) => void\n  ): () => void {\n    if (this.updatesEventSource) {\n      this.updatesEventSource.close();\n    }\n\n    const updatesUrl = new URL(\"/api/updates\", this.backendUrl).toString();\n    this.updatesEventSource = new EventSource(updatesUrl);\n\n    this.updatesEventSource.onmessage = (event) => {\n      try {\n        const parsed = JSON.parse(event.data) as SystemUpdate;\n        onUpdate(parsed);\n      } catch (error) {\n        console.error(\"Failed to parse system update SSE:\", error);\n        onError?.(error);\n      }\n    };\n\n    this.updatesEventSource.onerror = (error) => {\n      console.error(\"System updates SSE error:\", error);\n      onError?.(error);\n    };\n\n    return () => {\n      if (this.updatesEventSource) {\n        this.updatesEventSource.close();\n        this.updatesEventSource = null;\n      }\n    };\n  }\n\n  async fetchThreads(publicKey: string): Promise<BackendThreadMetadata[]> {\n    console.log(\"游댯 [fetchThreads] Called with publicKey:\", publicKey);\n    const url = `${this.backendUrl}/api/sessions?public_key=${encodeURIComponent(publicKey)}`;\n    console.log(\"游댯 [fetchThreads] URL:\", url);\n\n    const response = await fetch(url);\n    console.log(\"游댯 [fetchThreads] Response status:\", response.status);\n\n    if (!response.ok) {\n      console.error(\"游댮 [fetchThreads] Error:\", response.status);\n      throw new Error(`Failed to fetch threads: HTTP ${response.status}`);\n    }\n\n    const data = (await response.json()) as BackendThreadMetadata[];\n    console.log(\"游릭 [fetchThreads] Success:\", data);\n    return data;\n  }\n\n  async createThread(publicKey?: string, title?: string): Promise<CreateThreadResponse> {\n    console.log(\"游댯 [createThread] Called with publicKey:\", publicKey, \"title:\", title);\n    const body: Record<string, string> = {};\n    if (publicKey) {\n      body.public_key = publicKey;\n    }\n    if (title) {\n      body.title = title;\n    }\n    console.log(\"游댯 [createThread] Request body:\", body);\n\n    const url = `${this.backendUrl}/api/sessions`;\n    console.log(\"游댯 [createThread] URL:\", url);\n\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify(body),\n    });\n    console.log(\"游댯 [createThread] Response status:\", response.status);\n\n    if (!response.ok) {\n      console.error(\"游댮 [createThread] Error:\", response.status);\n      throw new Error(`Failed to create thread: HTTP ${response.status}`);\n    }\n\n    const data = (await response.json()) as CreateThreadResponse;\n    console.log(\"游릭 [createThread] Success:\", data);\n    return data;\n  }\n\n  async archiveThread(sessionId: string): Promise<void> {\n    console.log(\"游댯 [archiveThread] Called with sessionId:\", sessionId);\n    const url = `${this.backendUrl}/api/sessions/${encodeURIComponent(sessionId)}/archive`;\n    console.log(\"游댯 [archiveThread] URL:\", url);\n\n    const response = await fetch(url, { method: \"POST\" });\n    console.log(\"游댯 [archiveThread] Response status:\", response.status);\n\n    if (!response.ok) {\n      console.error(\"游댮 [archiveThread] Error:\", response.status);\n      throw new Error(`Failed to archive thread: HTTP ${response.status}`);\n    }\n    console.log(\"游릭 [archiveThread] Success\");\n  }\n\n  async unarchiveThread(sessionId: string): Promise<void> {\n    console.log(\"游댯 [unarchiveThread] Called with sessionId:\", sessionId);\n    const url = `${this.backendUrl}/api/sessions/${encodeURIComponent(sessionId)}/unarchive`;\n    console.log(\"游댯 [unarchiveThread] URL:\", url);\n\n    const response = await fetch(url, { method: \"POST\" });\n    console.log(\"游댯 [unarchiveThread] Response status:\", response.status);\n\n    if (!response.ok) {\n      console.error(\"游댮 [unarchiveThread] Error:\", response.status);\n      throw new Error(`Failed to unarchive thread: HTTP ${response.status}`);\n    }\n    console.log(\"游릭 [unarchiveThread] Success\");\n  }\n\n  async deleteThread(sessionId: string): Promise<void> {\n    console.log(\"游댯 [deleteThread] Called with sessionId:\", sessionId);\n    const url = `${this.backendUrl}/api/sessions/${encodeURIComponent(sessionId)}`;\n    console.log(\"游댯 [deleteThread] URL:\", url);\n\n    const response = await fetch(url, { method: \"DELETE\" });\n    console.log(\"游댯 [deleteThread] Response status:\", response.status);\n\n    if (!response.ok) {\n      console.error(\"游댮 [deleteThread] Error:\", response.status);\n      throw new Error(`Failed to delete thread: HTTP ${response.status}`);\n    }\n    console.log(\"游릭 [deleteThread] Success\");\n  }\n\n  async renameThread(sessionId: string, newTitle: string): Promise<void> {\n    console.log(\"游댯 [renameThread] Called with sessionId:\", sessionId, \"newTitle:\", newTitle);\n    const url = `${this.backendUrl}/api/sessions/${encodeURIComponent(sessionId)}`;\n    console.log(\"游댯 [renameThread] URL:\", url);\n\n    const response = await fetch(url, {\n      method: \"PATCH\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({ title: newTitle }),\n    });\n    console.log(\"游댯 [renameThread] Response status:\", response.status);\n\n    if (!response.ok) {\n      console.error(\"游댮 [renameThread] Error:\", response.status);\n      throw new Error(`Failed to rename thread: HTTP ${response.status}`);\n    }\n    console.log(\"游릭 [renameThread] Success\");\n  }\n}\n","\"use client\";\n\nimport type { ReactNode } from \"react\";\nimport { useCallback, useEffect, useMemo, useRef, useState } from \"react\";\nimport {\n  AssistantRuntimeProvider,\n  useExternalStoreRuntime,\n  type AppendMessage,\n  type ThreadMessageLike,\n} from \"@assistant-ui/react\";\n\nimport { BackendApi } from \"../api/client\";\nimport type { SessionMessage } from \"../api/types\";\nimport { createMessageHandlers } from \"./message-handlers\";\nimport { createPollingController } from \"./polling\";\nimport { createThreadListAdapter, normalizeBackendThreads } from \"./thread-list-adapter\";\nimport { RuntimeActionsProvider } from \"./hooks\";\nimport { isPlaceholderTitle, isTempThreadId } from \"./utils\";\nimport { constructSystemMessage, constructThreadMessage } from \"../utils/conversion\";\nimport { useThreadContext } from \"../state/thread-context\";\nimport type { ThreadMetadata } from \"../state/types\";\n\nexport type AomiRuntimeProviderProps = {\n  children: ReactNode;\n  backendUrl?: string;\n  publicKey?: string;\n};\n\nexport function AomiRuntimeProvider({\n  children,\n  backendUrl = \"http://localhost:8080\",\n  publicKey,\n}: Readonly<AomiRuntimeProviderProps>) {\n  const {\n    currentThreadId,\n    setCurrentThreadId,\n    bumpThreadViewKey,\n    threads,\n    setThreads,\n    threadMetadata,\n    setThreadMetadata,\n    threadCnt,\n    setThreadCnt,\n    getThreadMessages,\n    setThreadMessages,\n    updateThreadMetadata,\n  } = useThreadContext();\n\n  const [isRunning, setIsRunning] = useState(false);\n  const backendApiRef = useRef(new BackendApi(backendUrl));\n  const pollingIntervalRef = useRef<ReturnType<typeof setInterval> | null>(null);\n  const pendingSystemMessagesRef = useRef<Map<string, string[]>>(new Map());\n  const pendingChatMessagesRef = useRef<Map<string, string[]>>(new Map());\n  const creatingThreadIdRef = useRef<string | null>(null);\n  const createThreadPromiseRef = useRef<Promise<void> | null>(null);\n\n  const findPendingThreadId = useCallback(() => {\n    if (creatingThreadIdRef.current) return creatingThreadIdRef.current;\n    for (const [id, meta] of threadMetadata.entries()) {\n      if (meta.status === \"pending\") return id;\n    }\n    return null;\n  }, [threadMetadata]);\n\n  const currentThreadIdRef = useRef(currentThreadId);\n  useEffect(() => {\n    currentThreadIdRef.current = currentThreadId;\n  }, [currentThreadId]);\n\n  const skipInitialFetchRef = useRef<Set<string>>(new Set());\n  const tempToBackendIdRef = useRef<Map<string, string>>(new Map());\n\n  const resolveThreadId = useCallback((threadId: string): string => {\n    return tempToBackendIdRef.current.get(threadId) || threadId;\n  }, []);\n\n  const findTempIdForBackendId = useCallback((backendId: string): string | undefined => {\n    for (const [tempId, bId] of tempToBackendIdRef.current.entries()) {\n      if (bId === backendId) return tempId;\n    }\n    return undefined;\n  }, []);\n\n  const isThreadReady = useCallback((threadId: string): boolean => {\n    if (!isTempThreadId(threadId)) return true;\n    return tempToBackendIdRef.current.has(threadId);\n  }, []);\n\n  const applyMessages = useCallback(\n    (msgs?: SessionMessage[] | null) => {\n      if (!msgs) return;\n\n      const activeThreadId = currentThreadIdRef.current;\n      const hasPendingMessages =\n        pendingChatMessagesRef.current.has(activeThreadId) &&\n        (pendingChatMessagesRef.current.get(activeThreadId)?.length ?? 0) > 0;\n      if (hasPendingMessages) {\n        console.log(\"Skipping applyMessages - pending messages exist for thread:\", activeThreadId);\n        return;\n      }\n\n      const threadMessages: ThreadMessageLike[] = [];\n\n      for (const msg of msgs) {\n        if (msg.sender === \"system\") {\n          const systemMessage = constructSystemMessage(msg);\n          if (systemMessage) {\n            threadMessages.push(systemMessage);\n          }\n          continue;\n        }\n        const threadMessage = constructThreadMessage(msg);\n        if (threadMessage) {\n          threadMessages.push(threadMessage);\n        }\n      }\n\n      setThreadMessages(activeThreadId, threadMessages);\n    },\n    [setThreadMessages]\n  );\n\n  useEffect(() => {\n    backendApiRef.current = new BackendApi(backendUrl);\n  }, [backendUrl]);\n\n  const { startPolling, stopPolling } = useMemo(\n    () =>\n      createPollingController({\n        backendApiRef,\n        pollingIntervalRef,\n        resolveThreadId,\n        applyMessages,\n        isThreadReady,\n        currentThreadIdRef,\n        setIsRunning,\n      }),\n    [applyMessages, isThreadReady, resolveThreadId]\n  );\n\n  useEffect(() => {\n    const fetchInitialState = async () => {\n      const threadId = currentThreadIdRef.current;\n      if (isTempThreadId(threadId) && !tempToBackendIdRef.current.has(threadId)) {\n        setIsRunning(false);\n        return;\n      }\n\n      if (skipInitialFetchRef.current.has(threadId)) {\n        skipInitialFetchRef.current.delete(threadId);\n        setIsRunning(false);\n        return;\n      }\n\n      const backendThreadId = resolveThreadId(threadId);\n\n      try {\n        const state = await backendApiRef.current.fetchState(backendThreadId);\n        if (state.session_exists === false) {\n          setIsRunning(false);\n          return;\n        }\n        applyMessages(state.messages);\n\n        if (state.is_processing) {\n          setIsRunning(true);\n          startPolling();\n        } else {\n          setIsRunning(false);\n        }\n      } catch (error) {\n        console.error(\"Failed to fetch initial state:\", error);\n      }\n    };\n\n    void fetchInitialState();\n    return () => {\n      stopPolling();\n    };\n  }, [applyMessages, resolveThreadId, startPolling, stopPolling]);\n\n  useEffect(() => {\n    if (!publicKey) return;\n\n    const fetchThreadList = async () => {\n      try {\n        const threadList = await backendApiRef.current.fetchThreads(publicKey);\n        const { metadata, maxChatNum } = normalizeBackendThreads(threadList, threadMetadata, threadCnt);\n        setThreadMetadata(metadata);\n        if (maxChatNum > threadCnt) {\n          setThreadCnt(maxChatNum);\n        }\n      } catch (error) {\n        console.error(\"Failed to fetch thread list:\", error);\n      }\n    };\n\n    void fetchThreadList();\n  }, [publicKey, setThreadCnt, setThreadMetadata, threadCnt, threadMetadata]);\n\n  const threadListAdapter = useMemo(\n    () =>\n      createThreadListAdapter({\n        currentThreadId,\n        currentThreadIdRef,\n        threadMetadata,\n        setThreadMetadata,\n        setThreads,\n        setThreadMessages,\n        setCurrentThreadId,\n        setIsRunning,\n        bumpThreadViewKey,\n        findPendingThreadId,\n        creatingThreadIdRef,\n        createThreadPromiseRef,\n        pendingChatMessagesRef,\n        pendingSystemMessagesRef,\n        tempToBackendIdRef,\n        skipInitialFetchRef,\n        backendApiRef,\n        publicKey,\n        threadCnt,\n        setThreadCnt,\n        resolveThreadId,\n        startPolling,\n        updateThreadMetadata: (id: string, updates: Partial<ThreadMetadata>) =>\n          updateThreadMetadata(id, updates),\n      }),\n    [\n      backendApiRef,\n      bumpThreadViewKey,\n      currentThreadId,\n      findPendingThreadId,\n      publicKey,\n      resolveThreadId,\n      setCurrentThreadId,\n      setIsRunning,\n      setThreadCnt,\n      setThreadMetadata,\n      setThreadMessages,\n      setThreads,\n      startPolling,\n      threadCnt,\n      threadMetadata,\n      updateThreadMetadata,\n    ]\n  );\n\n  const currentMessages = getThreadMessages(currentThreadId);\n\n  const {\n    onNew,\n    onCancel,\n    sendSystemMessage,\n    sendSystemMessageNow,\n    flushPendingSystemMessages,\n    flushPendingChatMessages,\n  } = useMemo(\n    () =>\n      createMessageHandlers({\n        backendApiRef,\n        resolveThreadId,\n        getThreadMessages,\n        setThreadMessages,\n        setIsRunning,\n        startPolling,\n        stopPolling,\n        isThreadReady,\n        pendingSystemMessagesRef,\n        pendingChatMessagesRef,\n        updateThreadMetadata,\n        getCurrentThreadId: () => currentThreadIdRef.current,\n        getCurrentMessages: () => getThreadMessages(currentThreadIdRef.current),\n      }),\n    [\n      backendApiRef,\n      getThreadMessages,\n      isThreadReady,\n      resolveThreadId,\n      setThreadMessages,\n      setIsRunning,\n      startPolling,\n      stopPolling,\n      updateThreadMetadata,\n    ]\n  );\n\n  useEffect(() => {\n    if (isTempThreadId(currentThreadId)) return;\n    const hasUserMessages = currentMessages.some((msg) => msg.role === \"user\");\n    if (hasUserMessages) {\n      void flushPendingSystemMessages(currentThreadId);\n    }\n  }, [currentMessages, currentThreadId, flushPendingSystemMessages]);\n\n  useEffect(() => {\n    const unsubscribe = backendApiRef.current.subscribeToUpdates(\n      (update) => {\n        if (update.type !== \"TitleChanged\") return;\n        const sessionId = update.data.session_id;\n        const newTitle = update.data.new_title;\n\n        const tempId = findTempIdForBackendId(sessionId);\n        const threadIdToUpdate = tempId || sessionId;\n\n        setThreadMetadata((prev) => {\n          const next = new Map(prev);\n          const existing = next.get(threadIdToUpdate);\n          const normalizedTitle = isPlaceholderTitle(newTitle) ? \"\" : newTitle;\n          const nextStatus = existing?.status === \"archived\" ? \"archived\" : \"regular\";\n          next.set(threadIdToUpdate, {\n            title: normalizedTitle,\n            status: nextStatus,\n            lastActiveAt: existing?.lastActiveAt ?? new Date().toISOString(),\n          });\n          return next;\n        });\n        if (!isPlaceholderTitle(newTitle) && creatingThreadIdRef.current === threadIdToUpdate) {\n          creatingThreadIdRef.current = null;\n        }\n      },\n      (error) => {\n        console.error(\"Failed to handle system update SSE:\", error);\n      }\n    );\n\n    return () => {\n      unsubscribe();\n    };\n  }, [backendUrl, setThreadMetadata, findTempIdForBackendId]);\n\n  useEffect(() => {\n    const threadId = currentThreadIdRef.current;\n    if (!isTempThreadId(threadId)) return;\n    if (!tempToBackendIdRef.current.has(threadId)) return;\n    void flushPendingChatMessages(threadId);\n  }, [flushPendingChatMessages]);\n\n  const runtime = useExternalStoreRuntime({\n    messages: currentMessages,\n    setMessages: (msgs) => setThreadMessages(currentThreadIdRef.current, [...msgs]),\n    isRunning,\n    onNew: (message: AppendMessage) => onNew(message),\n    onCancel,\n    convertMessage: (msg) => msg,\n    adapters: {\n      threadList: threadListAdapter,\n    },\n  });\n\n  return (\n    <RuntimeActionsProvider value={{ sendSystemMessage }}>\n      <AssistantRuntimeProvider runtime={runtime}>{children}</AssistantRuntimeProvider>\n    </RuntimeActionsProvider>\n  );\n}\n","import type { ThreadMessageLike } from \"@assistant-ui/react\";\n\nimport type { SessionMessage } from \"../api/types\";\n\ntype MessageContentPart = Exclude<ThreadMessageLike[\"content\"], string> extends readonly (infer U)[] ? U : never;\n\nexport function constructThreadMessage(msg: SessionMessage): ThreadMessageLike | null {\n  if (msg.sender === \"system\") return null;\n\n  const content: MessageContentPart[] = [];\n  const role: ThreadMessageLike[\"role\"] = msg.sender === \"user\" ? \"user\" : \"assistant\";\n\n  if (msg.content) {\n    content.push({ type: \"text\" as const, text: msg.content });\n  }\n\n  const [topic, toolContent] = parseToolStream(msg.tool_stream) ?? [];\n  if (topic && toolContent) {\n    content.push({\n      type: \"tool-call\" as const,\n      toolCallId: `tool_${Date.now()}`,\n      toolName: topic,\n      args: undefined,\n      result: (() => {\n        try {\n          return JSON.parse(toolContent);\n        } catch {\n          return { args: toolContent };\n        }\n      })(),\n    });\n  }\n\n  const threadMessage = {\n    role,\n    content: (content.length > 0 ? content : [{ type: \"text\" as const, text: \"\" }]) as ThreadMessageLike[\"content\"],\n    ...(msg.timestamp && { createdAt: new Date(msg.timestamp) }),\n  } satisfies ThreadMessageLike;\n\n  return threadMessage;\n}\n\nexport function constructSystemMessage(msg: SessionMessage): ThreadMessageLike | null {\n  const [topic] = parseToolStream(msg.tool_stream) ?? [];\n  const messageText = topic || msg.content || \"\";\n  const timestamp = parseTimestamp(msg.timestamp);\n\n  if (!messageText.trim()) return null;\n\n  return {\n    role: \"system\",\n    content: [{ type: \"text\", text: messageText }],\n    ...(timestamp && { createdAt: timestamp }),\n  } satisfies ThreadMessageLike;\n}\n\nexport function constructUITool(): string {\n  return \"\";\n}\n\nfunction parseTimestamp(timestamp?: string) {\n  if (!timestamp) return undefined;\n  const parsed = new Date(timestamp);\n  return Number.isNaN(parsed.valueOf()) ? undefined : parsed;\n}\n\nfunction parseToolStream(toolStream: SessionMessage[\"tool_stream\"]): [string, string] | null {\n  if (!toolStream) return null;\n\n  if (Array.isArray(toolStream) && toolStream.length === 2) {\n    const [topic, content] = toolStream;\n    return [String(topic), content];\n  }\n\n  if (typeof toolStream === \"object\") {\n    const topic = (toolStream as { topic?: unknown }).topic;\n    const content = (toolStream as { content?: unknown }).content;\n    return topic ? [String(topic), String(content)] : null;\n  }\n\n  return null;\n}\n","import type { MutableRefObject } from \"react\";\nimport type { AppendMessage, ThreadMessageLike } from \"@assistant-ui/react\";\n\nimport type { BackendApi } from \"../api/client\";\nimport type { ThreadMetadata } from \"../state/types\";\nimport { constructSystemMessage } from \"../utils/conversion\";\n\nexport type MessageHandlerDependencies = {\n  backendApiRef: MutableRefObject<BackendApi>;\n  resolveThreadId: (threadId: string) => string;\n  getThreadMessages: (threadId: string) => ThreadMessageLike[];\n  setThreadMessages: (threadId: string, messages: ThreadMessageLike[]) => void;\n  setIsRunning: (running: boolean) => void;\n  startPolling: () => void;\n  stopPolling: () => void;\n  isThreadReady: (threadId: string) => boolean;\n  pendingSystemMessagesRef: MutableRefObject<Map<string, string[]>>;\n  pendingChatMessagesRef: MutableRefObject<Map<string, string[]>>;\n  updateThreadMetadata: (threadId: string, updates: Partial<ThreadMetadata>) => void;\n  getCurrentThreadId: () => string;\n  getCurrentMessages: () => ThreadMessageLike[];\n};\n\nexport function createMessageHandlers({\n  backendApiRef,\n  resolveThreadId,\n  getThreadMessages,\n  setThreadMessages,\n  setIsRunning,\n  startPolling,\n  stopPolling,\n  isThreadReady,\n  pendingSystemMessagesRef,\n  pendingChatMessagesRef,\n  updateThreadMetadata,\n  getCurrentThreadId,\n  getCurrentMessages,\n}: MessageHandlerDependencies) {\n  const sendSystemMessageNow = async (threadId: string, message: string) => {\n    const backendThreadId = resolveThreadId(threadId);\n    setIsRunning(true);\n    try {\n      const response = await backendApiRef.current.postSystemMessage(backendThreadId, message);\n\n      if (response.res) {\n        const systemMessage = constructSystemMessage(response.res);\n        if (systemMessage) {\n          const updatedMessages = [...getThreadMessages(threadId), systemMessage];\n          setThreadMessages(threadId, updatedMessages);\n        }\n      }\n\n      await startPolling();\n    } catch (error) {\n      console.error(\"Failed to send system message:\", error);\n      setIsRunning(false);\n    }\n  };\n\n  const flushPendingSystemMessages = async (threadId: string) => {\n    const pending = pendingSystemMessagesRef.current.get(threadId);\n    if (!pending?.length) return;\n\n    pendingSystemMessagesRef.current.delete(threadId);\n    for (const pendingMessage of pending) {\n      await sendSystemMessageNow(threadId, pendingMessage);\n    }\n  };\n\n  const flushPendingChatMessages = async (threadId: string) => {\n    const pending = pendingChatMessagesRef.current.get(threadId);\n    if (!pending?.length) return;\n\n    pendingChatMessagesRef.current.delete(threadId);\n    const backendThreadId = resolveThreadId(threadId);\n\n    for (const text of pending) {\n      try {\n        await backendApiRef.current.postChatMessage(backendThreadId, text);\n      } catch (error) {\n        console.error(\"Failed to send queued message:\", error);\n      }\n    }\n    startPolling();\n  };\n\n  const onNew = async (message: AppendMessage) => {\n    const text = message.content\n      .filter((part): part is Extract<typeof part, { type: \"text\" }> => part.type === \"text\")\n      .map((part: Extract<typeof message.content[number], { type: \"text\" }>) => part.text)\n      .join(\"\\n\");\n\n    if (!text) return;\n\n    const threadId = getCurrentThreadId();\n    const currentMessages = getCurrentMessages();\n    const userMessage: ThreadMessageLike = {\n      role: \"user\",\n      content: [{ type: \"text\", text }],\n      createdAt: new Date(),\n    };\n\n    setThreadMessages(threadId, [...currentMessages, userMessage]);\n    updateThreadMetadata(threadId, { lastActiveAt: new Date().toISOString() });\n\n    if (!isThreadReady(threadId)) {\n      console.log(\"Thread not ready yet; queuing message for later delivery.\");\n      setIsRunning(true);\n      const pending = pendingChatMessagesRef.current.get(threadId) || [];\n      pendingChatMessagesRef.current.set(threadId, [...pending, text]);\n      return;\n    }\n\n    const backendThreadId = resolveThreadId(threadId);\n\n    try {\n      setIsRunning(true);\n      await backendApiRef.current.postChatMessage(backendThreadId, text);\n      await flushPendingSystemMessages(threadId);\n      startPolling();\n    } catch (error) {\n      console.error(\"Failed to send message:\", error);\n      setIsRunning(false);\n    }\n  };\n\n  const sendSystemMessage = async (message: string) => {\n    const threadId = getCurrentThreadId();\n    if (!isThreadReady(threadId)) return;\n    const threadMessages = getThreadMessages(threadId);\n    const hasUserMessages = threadMessages.some((msg) => msg.role === \"user\");\n\n    if (!hasUserMessages) {\n      const pending = pendingSystemMessagesRef.current.get(threadId) || [];\n      pendingSystemMessagesRef.current.set(threadId, [...pending, message]);\n      return;\n    }\n\n    await sendSystemMessageNow(threadId, message);\n  };\n\n  const onCancel = async () => {\n    const threadId = getCurrentThreadId();\n    if (!isThreadReady(threadId)) return;\n    stopPolling();\n\n    const backendThreadId = resolveThreadId(threadId);\n\n    try {\n      await backendApiRef.current.postInterrupt(backendThreadId);\n      setIsRunning(false);\n    } catch (error) {\n      console.error(\"Failed to cancel:\", error);\n    }\n  };\n\n  return {\n    onNew,\n    onCancel,\n    sendSystemMessage,\n    sendSystemMessageNow,\n    flushPendingSystemMessages,\n    flushPendingChatMessages,\n  };\n}\n","import type { MutableRefObject } from \"react\";\n\nimport type { BackendApi } from \"../api/client\";\nimport type { SessionMessage } from \"../api/types\";\n\nexport type PollingDependencies = {\n  backendApiRef: MutableRefObject<BackendApi>;\n  pollingIntervalRef: MutableRefObject<ReturnType<typeof setInterval> | null>;\n  resolveThreadId: (threadId: string) => string;\n  applyMessages: (messages?: SessionMessage[] | null) => void;\n  isThreadReady: (threadId: string) => boolean;\n  currentThreadIdRef: MutableRefObject<string>;\n  setIsRunning: (running: boolean) => void;\n};\n\nexport function createPollingController({\n  backendApiRef,\n  pollingIntervalRef,\n  resolveThreadId,\n  applyMessages,\n  isThreadReady,\n  currentThreadIdRef,\n  setIsRunning,\n}: PollingDependencies) {\n  const stopPolling = () => {\n    if (pollingIntervalRef.current) {\n      clearInterval(pollingIntervalRef.current);\n      pollingIntervalRef.current = null;\n    }\n  };\n\n  const startPolling = () => {\n    const threadId = currentThreadIdRef.current;\n    if (!isThreadReady(threadId)) return;\n    if (pollingIntervalRef.current) return;\n    const backendThreadId = resolveThreadId(threadId);\n    setIsRunning(true);\n    pollingIntervalRef.current = setInterval(async () => {\n      try {\n        const state = await backendApiRef.current.fetchState(backendThreadId);\n        if (state.session_exists === false) {\n          setIsRunning(false);\n          stopPolling();\n          return;\n        }\n        applyMessages(state.messages);\n\n        if (!state.is_processing) {\n          setIsRunning(false);\n          stopPolling();\n        }\n      } catch (error) {\n        console.error(\"Polling error:\", error);\n        stopPolling();\n        setIsRunning(false);\n      }\n    }, 500);\n  };\n\n  return { startPolling, stopPolling };\n}\n","export const isTempThreadId = (id: string) => id.startsWith(\"temp-\");\n\nexport const parseTimestamp = (value?: string | number) => {\n  if (value === undefined || value === null) return 0;\n  if (typeof value === \"number\") {\n    return Number.isFinite(value) ? (value < 1e12 ? value * 1000 : value) : 0;\n  }\n\n  const numeric = Number(value);\n  if (!Number.isNaN(numeric)) {\n    return numeric < 1e12 ? numeric * 1000 : numeric;\n  }\n\n  const ts = Date.parse(value);\n  return Number.isNaN(ts) ? 0 : ts;\n};\n\nexport const isPlaceholderTitle = (title?: string) => {\n  const normalized = title?.trim() ?? \"\";\n  return !normalized || normalized.startsWith(\"#[\");\n};\n","import type { Dispatch, MutableRefObject, SetStateAction } from \"react\";\nimport type {\n  ExternalStoreThreadData,\n  ExternalStoreThreadListAdapter,\n  ThreadMessageLike,\n} from \"@assistant-ui/react\";\n\nimport type { BackendApi } from \"../api/client\";\nimport type { BackendThreadMetadata } from \"../api/types\";\nimport type { ThreadMetadata } from \"../state/types\";\nimport { isPlaceholderTitle, isTempThreadId, parseTimestamp } from \"./utils\";\n\nexport type ThreadListAdapterDependencies = {\n  currentThreadId: string;\n  currentThreadIdRef: MutableRefObject<string>;\n  threadMetadata: Map<string, ThreadMetadata>;\n  setThreadMetadata: Dispatch<SetStateAction<Map<string, ThreadMetadata>>>;\n  setThreads: Dispatch<SetStateAction<Map<string, ThreadMessageLike[]>>>;\n  setThreadMessages: (threadId: string, messages: ThreadMessageLike[]) => void;\n  setCurrentThreadId: (id: string) => void;\n  setIsRunning: (running: boolean) => void;\n  bumpThreadViewKey: () => void;\n  findPendingThreadId: () => string | null;\n  creatingThreadIdRef: MutableRefObject<string | null>;\n  createThreadPromiseRef: MutableRefObject<Promise<void> | null>;\n  pendingChatMessagesRef: MutableRefObject<Map<string, string[]>>;\n  pendingSystemMessagesRef: MutableRefObject<Map<string, string[]>>;\n  tempToBackendIdRef: MutableRefObject<Map<string, string>>;\n  skipInitialFetchRef: MutableRefObject<Set<string>>;\n  backendApiRef: MutableRefObject<BackendApi>;\n  publicKey?: string;\n  threadCnt: number;\n  setThreadCnt: Dispatch<SetStateAction<number>>;\n  resolveThreadId: (threadId: string) => string;\n  startPolling: () => void;\n  updateThreadMetadata: (threadId: string, updates: Partial<ThreadMetadata>) => void;\n};\n\nexport function normalizeBackendThreads(\n  threads: BackendThreadMetadata[],\n  existingMetadata: Map<string, ThreadMetadata>,\n  threadCnt: number\n) {\n  const newMetadata = new Map(existingMetadata);\n  let maxChatNum = threadCnt;\n\n  for (const thread of threads) {\n    const rawTitle = thread.title || \"New Chat\";\n    const title = isPlaceholderTitle(rawTitle) ? \"\" : rawTitle;\n    const lastActive =\n      thread.last_active_at ||\n      thread.updated_at ||\n      thread.created_at ||\n      newMetadata.get(thread.session_id)?.lastActiveAt ||\n      new Date().toISOString();\n    newMetadata.set(thread.session_id, {\n      title,\n      status: thread.is_archived ? \"archived\" : \"regular\",\n      lastActiveAt: lastActive,\n    });\n\n    const match = title.match(/^Chat (\\d+)$/);\n    if (match) {\n      const num = parseInt(match[1], 10);\n      if (num > maxChatNum) {\n        maxChatNum = num;\n      }\n    }\n  }\n\n  return { metadata: newMetadata, maxChatNum };\n}\n\nexport function createThreadListAdapter({\n  currentThreadId,\n  currentThreadIdRef,\n  threadMetadata,\n  setThreadMetadata,\n  setThreads,\n  setThreadMessages,\n  setCurrentThreadId,\n  setIsRunning,\n  bumpThreadViewKey,\n  findPendingThreadId,\n  creatingThreadIdRef,\n  createThreadPromiseRef,\n  pendingChatMessagesRef,\n  pendingSystemMessagesRef,\n  tempToBackendIdRef,\n  skipInitialFetchRef,\n  backendApiRef,\n  publicKey,\n  threadCnt,\n  setThreadCnt,\n  resolveThreadId,\n  startPolling,\n  updateThreadMetadata,\n}: ThreadListAdapterDependencies): ExternalStoreThreadListAdapter {\n  const sortByLastActiveDesc = (\n    [, metaA]: [string, ThreadMetadata],\n    [, metaB]: [string, ThreadMetadata]\n  ) => {\n    const tsA = parseTimestamp(metaA.lastActiveAt);\n    const tsB = parseTimestamp(metaB.lastActiveAt);\n    return tsB - tsA;\n  };\n\n  const regularThreads = Array.from(threadMetadata.entries())\n    .filter(([_, meta]) => meta.status === \"regular\")\n    .filter(([_, meta]) => !isPlaceholderTitle(meta.title))\n    .sort(sortByLastActiveDesc)\n    .map(([id, meta]): ExternalStoreThreadData<\"regular\"> => ({\n      id,\n      title: meta.title || \"New Chat\",\n      status: \"regular\",\n    }));\n\n  const archivedThreadsArray = Array.from(threadMetadata.entries())\n    .filter(([_, meta]) => meta.status === \"archived\")\n    .filter(([_, meta]) => !isPlaceholderTitle(meta.title))\n    .sort(sortByLastActiveDesc)\n    .map(([id, meta]): ExternalStoreThreadData<\"archived\"> => ({\n      id,\n      title: meta.title || \"New Chat\",\n      status: \"archived\",\n    }));\n\n  return {\n    threadId: currentThreadId,\n    threads: regularThreads,\n    archivedThreads: archivedThreadsArray,\n\n    onSwitchToNewThread: async () => {\n      const preparePendingThread = (newId: string) => {\n        const previousPendingId = creatingThreadIdRef.current;\n        if (previousPendingId && previousPendingId !== newId) {\n          setThreadMetadata((prev) => {\n            const next = new Map(prev);\n            next.delete(previousPendingId);\n            return next;\n          });\n          setThreads((prev) => {\n            const next = new Map(prev);\n            next.delete(previousPendingId);\n            return next;\n          });\n          pendingChatMessagesRef.current.delete(previousPendingId);\n          pendingSystemMessagesRef.current.delete(previousPendingId);\n          tempToBackendIdRef.current.delete(previousPendingId);\n          skipInitialFetchRef.current.delete(previousPendingId);\n        }\n\n        creatingThreadIdRef.current = newId;\n        pendingChatMessagesRef.current.delete(newId);\n        pendingSystemMessagesRef.current.delete(newId);\n        setThreadMetadata((prev) =>\n          new Map(prev).set(newId, {\n            title: \"New Chat\",\n            status: \"pending\",\n            lastActiveAt: new Date().toISOString(),\n          })\n        );\n        setThreadMessages(newId, []);\n        setCurrentThreadId(newId);\n        setIsRunning(false);\n        bumpThreadViewKey();\n      };\n\n      const existingPendingId = findPendingThreadId();\n      if (existingPendingId) {\n        preparePendingThread(existingPendingId);\n        return;\n      }\n\n      if (createThreadPromiseRef.current) {\n        preparePendingThread(creatingThreadIdRef.current ?? `temp-${crypto.randomUUID()}`);\n        return;\n      }\n\n      const tempId = `temp-${crypto.randomUUID()}`;\n      preparePendingThread(tempId);\n\n      const createPromise = backendApiRef.current\n        .createThread(publicKey, undefined)\n        .then(async (newThread) => {\n          const uiThreadId = creatingThreadIdRef.current ?? tempId;\n          const backendId = newThread.session_id;\n\n          tempToBackendIdRef.current.set(uiThreadId, backendId);\n          skipInitialFetchRef.current.add(uiThreadId);\n\n          const backendTitle = newThread.title;\n          if (backendTitle && !isPlaceholderTitle(backendTitle)) {\n            setThreadMetadata((prev) => {\n              const next = new Map(prev);\n              const existing = next.get(uiThreadId);\n              const nextStatus = existing?.status === \"archived\" ? \"archived\" : \"regular\";\n              next.set(uiThreadId, {\n                title: backendTitle,\n                status: nextStatus,\n                lastActiveAt: existing?.lastActiveAt ?? new Date().toISOString(),\n              });\n              return next;\n            });\n            if (creatingThreadIdRef.current === uiThreadId) {\n              creatingThreadIdRef.current = null;\n            }\n          }\n\n          const pendingMessages = pendingChatMessagesRef.current.get(uiThreadId);\n          if (pendingMessages?.length) {\n            pendingChatMessagesRef.current.delete(uiThreadId);\n            for (const text of pendingMessages) {\n              try {\n                await backendApiRef.current.postChatMessage(backendId, text);\n              } catch (error) {\n                console.error(\"Failed to send queued message:\", error);\n              }\n            }\n            if (currentThreadIdRef.current === uiThreadId) {\n              startPolling();\n            }\n          }\n        })\n        .catch((error) => {\n          console.error(\"Failed to create new thread:\", error);\n          const failedId = creatingThreadIdRef.current ?? tempId;\n          setThreadMetadata((prev) => {\n            const next = new Map(prev);\n            next.delete(failedId);\n            return next;\n          });\n          setThreads((prev) => {\n            const next = new Map(prev);\n            next.delete(failedId);\n            return next;\n          });\n          if (creatingThreadIdRef.current === failedId) {\n            creatingThreadIdRef.current = null;\n          }\n        })\n        .finally(() => {\n          createThreadPromiseRef.current = null;\n        });\n\n      createThreadPromiseRef.current = createPromise;\n    },\n\n    onSwitchToThread: (threadId: string) => {\n      setCurrentThreadId(threadId);\n    },\n\n    onRename: async (threadId: string, newTitle: string) => {\n      updateThreadMetadata(threadId, { title: isPlaceholderTitle(newTitle) ? \"\" : newTitle });\n\n      try {\n        await backendApiRef.current.renameThread(threadId, newTitle);\n      } catch (error) {\n        console.error(\"Failed to rename thread:\", error);\n      }\n    },\n\n    onArchive: async (threadId: string) => {\n      updateThreadMetadata(threadId, { status: \"archived\" });\n\n      try {\n        await backendApiRef.current.archiveThread(threadId);\n      } catch (error) {\n        console.error(\"Failed to archive thread:\", error);\n        updateThreadMetadata(threadId, { status: \"regular\" });\n      }\n    },\n\n    onUnarchive: async (threadId: string) => {\n      updateThreadMetadata(threadId, { status: \"regular\" });\n\n      try {\n        await backendApiRef.current.unarchiveThread(threadId);\n      } catch (error) {\n        console.error(\"Failed to unarchive thread:\", error);\n        updateThreadMetadata(threadId, { status: \"archived\" });\n      }\n    },\n\n    onDelete: async (threadId: string) => {\n      try {\n        await backendApiRef.current.deleteThread(threadId);\n\n        setThreadMetadata((prev) => {\n          const next = new Map(prev);\n          next.delete(threadId);\n          return next;\n        });\n        setThreads((prev) => {\n          const next = new Map(prev);\n          next.delete(threadId);\n          return next;\n        });\n\n        if (currentThreadId === threadId) {\n          const firstRegularThread = Array.from(threadMetadata.entries()).find(\n            ([id, meta]) => meta.status === \"regular\" && id !== threadId\n          );\n\n          if (firstRegularThread) {\n            setCurrentThreadId(firstRegularThread[0]);\n          } else {\n            const defaultId = \"default-session\";\n            setThreadMetadata((prev) =>\n              new Map(prev).set(defaultId, {\n                title: \"New Chat\",\n                status: \"regular\",\n                lastActiveAt: new Date().toISOString(),\n              })\n            );\n            setThreadMessages(defaultId, []);\n            setCurrentThreadId(defaultId);\n          }\n        }\n      } catch (error) {\n        console.error(\"Failed to delete thread:\", error);\n        throw error;\n      }\n    },\n  };\n}\n","\"use client\";\n\nimport { createContext, useContext } from \"react\";\n\nexport type RuntimeActions = {\n  sendSystemMessage: (message: string) => Promise<void>;\n};\n\nconst RuntimeActionsContext = createContext<RuntimeActions | undefined>(undefined);\n\nexport const RuntimeActionsProvider = RuntimeActionsContext.Provider;\n\nexport function useRuntimeActions(): RuntimeActions {\n  const context = useContext(RuntimeActionsContext);\n  if (!context) {\n    throw new Error(\"useRuntimeActions must be used within AomiRuntimeProvider\");\n  }\n  return context;\n}\n","\"use client\";\n\nimport { createContext, useCallback, useContext, useState, type ReactNode } from \"react\";\nimport type { ThreadMessageLike } from \"@assistant-ui/react\";\n\nimport type { ThreadMetadata } from \"./types\";\n\nexport type ThreadContextValue = {\n  currentThreadId: string;\n  setCurrentThreadId: (id: string) => void;\n  threadViewKey: number;\n  bumpThreadViewKey: () => void;\n  threads: Map<string, ThreadMessageLike[]>;\n  setThreads: React.Dispatch<React.SetStateAction<Map<string, ThreadMessageLike[]>>>;\n  threadMetadata: Map<string, ThreadMetadata>;\n  setThreadMetadata: React.Dispatch<React.SetStateAction<Map<string, ThreadMetadata>>>;\n  threadCnt: number;\n  setThreadCnt: React.Dispatch<React.SetStateAction<number>>;\n  getThreadMessages: (threadId: string) => ThreadMessageLike[];\n  setThreadMessages: (threadId: string, messages: ThreadMessageLike[]) => void;\n  getThreadMetadata: (threadId: string) => ThreadMetadata | undefined;\n  updateThreadMetadata: (threadId: string, updates: Partial<ThreadMetadata>) => void;\n};\n\nexport type ThreadContextProviderProps = {\n  children: ReactNode;\n  initialThreadId?: string;\n};\n\nconst ThreadContext = createContext<ThreadContextValue | null>(null);\n\nexport function useThreadContext(): ThreadContextValue {\n  const context = useContext(ThreadContext);\n  if (!context) {\n    throw new Error(\n      \"useThreadContext must be used within ThreadContextProvider. \" +\n        \"Wrap your app with <ThreadContextProvider>...</ThreadContextProvider>\"\n    );\n  }\n  return context;\n}\n\nexport function ThreadContextProvider({\n  children,\n  initialThreadId,\n}: ThreadContextProviderProps) {\n  const [generateThreadId] = useState(() => {\n    const id = initialThreadId || crypto.randomUUID();\n    console.log(\"游댯 [ThreadContext] Initialized with thread ID:\", id);\n    return id;\n  });\n\n  const [threadCnt, setThreadCnt] = useState<number>(1);\n\n  const [threads, setThreads] = useState<Map<string, ThreadMessageLike[]>>(\n    () => new Map([[generateThreadId, []]])\n  );\n\n  const [threadMetadata, setThreadMetadata] = useState<Map<string, ThreadMetadata>>(\n    () =>\n      new Map([\n        [\n          generateThreadId,\n          { title: \"New Chat\", status: \"pending\", lastActiveAt: new Date().toISOString() },\n        ],\n      ])\n  );\n\n  const ensureThreadExists = useCallback(\n    (threadId: string) => {\n      setThreadMetadata((prev) => {\n        if (prev.has(threadId)) return prev;\n        const next = new Map(prev);\n        next.set(threadId, { title: \"New Chat\", status: \"regular\", lastActiveAt: new Date().toISOString() });\n        return next;\n      });\n\n      setThreads((prev) => {\n        if (prev.has(threadId)) return prev;\n        const next = new Map(prev);\n        next.set(threadId, []);\n        return next;\n      });\n    },\n    []\n  );\n\n  const [currentThreadId, _setCurrentThreadId] = useState(generateThreadId);\n  const [threadViewKey, setThreadViewKey] = useState(0);\n\n  const bumpThreadViewKey = useCallback(() => {\n    setThreadViewKey((prev) => prev + 1);\n  }, []);\n\n  const setCurrentThreadId = useCallback(\n    (threadId: string) => {\n      ensureThreadExists(threadId);\n      _setCurrentThreadId(threadId);\n    },\n    [ensureThreadExists]\n  );\n\n  const getThreadMessages = useCallback(\n    (threadId: string): ThreadMessageLike[] => {\n      return threads.get(threadId) || [];\n    },\n    [threads]\n  );\n\n  const setThreadMessages = useCallback((threadId: string, messages: ThreadMessageLike[]) => {\n    setThreads((prev) => {\n      const next = new Map(prev);\n      next.set(threadId, messages);\n      return next;\n    });\n  }, []);\n\n  const getThreadMetadata = useCallback(\n    (threadId: string): ThreadMetadata | undefined => {\n      return threadMetadata.get(threadId);\n    },\n    [threadMetadata]\n  );\n\n  const updateThreadMetadata = useCallback((threadId: string, updates: Partial<ThreadMetadata>) => {\n    setThreadMetadata((prev) => {\n      const existing = prev.get(threadId);\n      if (!existing) {\n        console.warn(`Thread metadata not found for threadId: ${threadId}`);\n        return prev;\n      }\n\n      const next = new Map(prev);\n      next.set(threadId, { ...existing, ...updates });\n      return next;\n    });\n  }, []);\n\n  const value: ThreadContextValue = {\n    currentThreadId,\n    setCurrentThreadId,\n    threadViewKey,\n    bumpThreadViewKey,\n    threads,\n    setThreads,\n    threadMetadata,\n    setThreadMetadata,\n    threadCnt,\n    setThreadCnt,\n    getThreadMessages,\n    setThreadMessages,\n    getThreadMetadata,\n    updateThreadMetadata,\n  };\n\n  return <ThreadContext.Provider value={value}>{children}</ThreadContext.Provider>;\n}\n\nexport function useCurrentThreadMessages(): ThreadMessageLike[] {\n  const { currentThreadId, getThreadMessages } = useThreadContext();\n  return getThreadMessages(currentThreadId);\n}\n\nexport function useCurrentThreadMetadata(): ThreadMetadata | undefined {\n  const { currentThreadId, getThreadMetadata } = useThreadContext();\n  return getThreadMetadata(currentThreadId);\n}\n","\"use client\";\n\nimport { useEffect, useRef } from \"react\";\n\nimport { useRuntimeActions } from \"../runtime/hooks\";\n\nexport type WalletButtonState = {\n  address?: string;\n  chainId?: number;\n  isConnected: boolean;\n  ensName?: string;\n};\n\nexport type WalletFooterProps = {\n  wallet: WalletButtonState;\n  setWallet: (data: Partial<WalletButtonState>) => void;\n};\n\nexport const getNetworkName = (chainId: number | string | undefined): string => {\n  if (chainId === undefined) return \"\";\n  const id = typeof chainId === \"string\" ? Number(chainId) : chainId;\n  switch (id) {\n    case 1:\n      return \"ethereum\";\n    case 137:\n      return \"polygon\";\n    case 42161:\n      return \"arbitrum\";\n    case 8453:\n      return \"base\";\n    case 10:\n      return \"optimism\";\n    case 11155111:\n      return \"sepolia\";\n    case 1337:\n    case 31337:\n      return \"testnet\";\n    case 59140:\n      return \"linea-sepolia\";\n    case 59144:\n      return \"linea\";\n    default:\n      return \"testnet\";\n  }\n};\n\nexport const formatAddress = (addr?: string): string =>\n  addr ? `${addr.slice(0, 6)}...${addr.slice(-4)}` : \"Connect Wallet\";\n\ntype WalletSystemMessageEmitterProps = {\n  wallet: WalletButtonState;\n};\n\nexport function WalletSystemMessageEmitter({ wallet }: WalletSystemMessageEmitterProps) {\n  const { sendSystemMessage } = useRuntimeActions();\n  const lastWalletRef = useRef<{\n    isConnected: boolean;\n    address?: string;\n    chainId?: number;\n  }>({ isConnected: false });\n\n  useEffect(() => {\n    const prev = lastWalletRef.current;\n    const { address, chainId, isConnected } = wallet;\n    const normalizedAddress = address?.toLowerCase();\n\n    if (\n      isConnected &&\n      normalizedAddress &&\n      chainId &&\n      (!prev.isConnected || prev.address !== normalizedAddress)\n    ) {\n      const networkName = getNetworkName(chainId);\n      const message = `User connected wallet with address ${normalizedAddress} on ${networkName} network (Chain ID: ${chainId}). Ready to help with transactions.`;\n      console.log(message);\n      void sendSystemMessage(message);\n      lastWalletRef.current = { isConnected: true, address: normalizedAddress, chainId };\n      return;\n    }\n\n    if (!isConnected && prev.isConnected) {\n      void sendSystemMessage(\"Wallet disconnected by user.\");\n      console.log(\"Wallet disconnected by user.\");\n      lastWalletRef.current = { isConnected: false };\n      return;\n    }\n\n    if (\n      isConnected &&\n      normalizedAddress &&\n      chainId &&\n      prev.isConnected &&\n      prev.address === normalizedAddress &&\n      prev.chainId !== chainId\n    ) {\n      const networkName = getNetworkName(chainId);\n      const message = `User switched wallet to ${networkName} network (Chain ID: ${chainId}).`;\n      console.log(message);\n      void sendSystemMessage(message);\n      lastWalletRef.current = { isConnected: true, address: normalizedAddress, chainId };\n    }\n  }, [wallet, sendSystemMessage]);\n\n  return null;\n}\n","import { clsx, type ClassValue } from \"clsx\";\nimport { twMerge } from \"tailwind-merge\";\n\nexport function cn(...inputs: ClassValue[]) {\n  return twMerge(clsx(inputs));\n}\n"],"mappings":"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","names":["import_react","parseTimestamp","parseTimestamp","_a","import_react","import_jsx_runtime","import_react"]}