{"version":3,"sources":["../src/backend/client.ts","../src/runtime/aomi-runtime.tsx","../src/contexts/event-context.tsx","../src/state/event-buffer.ts","../src/runtime/orchestrator.ts","../src/contexts/thread-context.tsx","../src/runtime/utils.ts","../src/state/backend-state.ts","../src/runtime/message-controller.ts","../src/runtime/polling-controller.ts","../src/handlers/wallet-handler.ts","../src/handlers/notification-handler.ts"],"sourcesContent":["import type {\n  ApiChatResponse,\n  ApiCreateThreadResponse,\n  ApiInterruptResponse,\n  ApiSSEEvent,\n  ApiStateResponse,\n  ApiSystemEvent,\n  ApiSystemResponse,\n  ApiThread,\n} from \"./types\";\n\nfunction toQueryString(payload: Record<string, unknown>): string {\n  const params = new URLSearchParams();\n  for (const [key, value] of Object.entries(payload)) {\n    if (value === undefined || value === null) continue;\n    params.set(key, String(value));\n  }\n  const qs = params.toString();\n  return qs ? `?${qs}` : \"\";\n}\n\nasync function postState<T>(\n  backendUrl: string,\n  path: string,\n  payload: Record<string, unknown>\n): Promise<T> {\n  const query = toQueryString(payload);\n  const url = `${backendUrl}${path}${query}`;\n  console.log(\"[postState] URL:\", url);\n  console.log(\"[postState] Payload:\", payload);\n\n  const response = await fetch(url, {\n    method: \"POST\",\n  });\n  console.log(\"[postState] Response status:\", response.status);\n\n  if (!response.ok) {\n    console.error(\"[postState] Error:\", response.status, response.statusText);\n    throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n  }\n\n  const data = (await response.json()) as T;\n  console.log(\"[postState] Success:\", data);\n  return data;\n}\n\ntype SSESubscription = {\n  eventSource: EventSource | null;\n  retries: number;\n  retryTimer: ReturnType<typeof setTimeout> | null;\n  stopped: boolean;\n  cleanup: () => void;\n};\n\nexport class BackendApi {\n  private connectionStatus = false;\n  private eventSource: EventSource | null = null;\n  private updatesEventSources = new Map<string, SSESubscription>();\n\n  constructor(private readonly backendUrl: string) {}\n\n  async fetchState(\n    sessionId: string,\n    options?: { signal?: AbortSignal }\n  ): Promise<ApiStateResponse> {\n    console.log(\"[fetchState] Called with sessionId:\", sessionId);\n    const url = `${this.backendUrl}/api/state?session_id=${encodeURIComponent(sessionId)}`;\n    console.log(\"[fetchState] URL:\", url);\n\n    const response = await fetch(url, { signal: options?.signal });\n    console.log(\"[fetchState] Response status:\", response.status, response.statusText);\n\n    if (!response.ok) {\n      console.error(\"[fetchState] Error:\", response.status, response.statusText);\n      throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n    }\n\n    const data = (await response.json()) as ApiStateResponse;\n    console.log(\"[fetchState] Success:\", data);\n    return data;\n  }\n\n  async postChatMessage(\n    sessionId: string,\n    message: string,\n    publicKey?: string\n  ): Promise<ApiChatResponse> {\n    console.log(\"[postChatMessage] Called with sessionId:\", sessionId, \"message:\", message);\n    const result = await postState<ApiChatResponse>(this.backendUrl, \"/api/chat\", {\n      message,\n      session_id: sessionId,\n      public_key: publicKey,\n    });\n    console.log(\"[postChatMessage] Success:\", result);\n    return result;\n  }\n\n  async postSystemMessage(sessionId: string, message: string): Promise<ApiSystemResponse> {\n    console.log(\"[postSystemMessage] Called with sessionId:\", sessionId, \"message:\", message);\n    const result = await postState<ApiSystemResponse>(this.backendUrl, \"/api/system\", {\n      message,\n      session_id: sessionId,\n    });\n    console.log(\"[postSystemMessage] Success:\", result);\n    return result;\n  }\n\n  async postInterrupt(sessionId: string): Promise<ApiInterruptResponse> {\n    console.log(\"[postInterrupt] Called with sessionId:\", sessionId);\n    const result = await postState<ApiInterruptResponse>(this.backendUrl, \"/api/interrupt\", {\n      session_id: sessionId,\n    });\n    console.log(\"[postInterrupt] Success:\", result);\n    return result;\n  }\n\n  disconnectSSE(): void {\n    if (this.eventSource) {\n      this.eventSource.close();\n      this.eventSource = null;\n    }\n    this.setConnectionStatus(false);\n  }\n\n  setConnectionStatus(on: boolean): void {\n    this.connectionStatus = on;\n  }\n\n  async connectSSE(sessionId: string, publicKey?: string) {\n    this.disconnectSSE();\n\n    try {\n      const url = new URL(`${this.backendUrl}/api/chat/stream`);\n      url.searchParams.set(\"session_id\", sessionId);\n      if (publicKey) {\n        url.searchParams.set(\"public_key\", publicKey);\n      }\n\n      this.eventSource = new EventSource(url.toString());\n\n      this.eventSource.onopen = () => {\n        console.log(\"SSE connection opened to:\", url.toString());\n        this.setConnectionStatus(true);\n      };\n\n      this.eventSource.onmessage = (event) => {\n        try {\n          JSON.parse(event.data);\n        } catch (error) {\n          console.error(\"Failed to parse SSE data:\", error);\n        }\n      };\n\n      this.eventSource.onerror = (error) => {\n        console.error(\"SSE connection error:\", error);\n      };\n    } catch (error) {\n      console.error(\"Failed to establish SSE connection:\", error);\n      this.handleConnectionError(sessionId, publicKey);\n    }\n  }\n\n  private handleConnectionError(sessionId: string, publicKey?: string): void {\n    this.setConnectionStatus(false);\n    let attempt = 0;\n    const total = 3;\n    if (attempt < total) {\n      attempt++;\n      console.log(`Attempting to reconnect (${attempt}/${total})...`);\n\n      setTimeout(() => {\n        this.connectSSE(sessionId, publicKey);\n      }, 100);\n    } else {\n      console.error(\"Max reconnection attempts reached\");\n      this.setConnectionStatus(false);\n    }\n  }\n\n  /**\n   * Subscribe to SSE updates for a session with automatic reconnection.\n   * Returns an unsubscribe function.\n   */\n  subscribeSSE(\n    sessionId: string,\n    onUpdate: (event: ApiSSEEvent) => void,\n    onError?: (error: unknown) => void\n  ): () => void {\n    const updatesUrl = new URL(\"/api/updates\", this.backendUrl);\n    updatesUrl.searchParams.set(\"session_id\", sessionId);\n    const updatesUrlString = updatesUrl.toString();\n\n    // Cleanup any existing subscription for this session\n    const existing = this.updatesEventSources.get(sessionId);\n    if (existing) {\n      existing.cleanup();\n      this.updatesEventSources.delete(sessionId);\n    }\n\n    const subscription: SSESubscription = {\n      eventSource: null,\n      retries: 0,\n      retryTimer: null,\n      stopped: false,\n      cleanup: () => {\n        subscription.stopped = true;\n        if (subscription.retryTimer) {\n          clearTimeout(subscription.retryTimer);\n          subscription.retryTimer = null;\n        }\n        if (subscription.eventSource) {\n          subscription.eventSource.close();\n          subscription.eventSource = null;\n        }\n      },\n    };\n\n    const scheduleRetry = () => {\n      subscription.retries += 1;\n      const delayMs = Math.min(500 * 2 ** (subscription.retries - 1), 10000);\n      console.warn(\n        `[SSE] retrying in ${delayMs}ms (attempt ${subscription.retries})`,\n        { sessionId }\n      );\n      subscription.retryTimer = setTimeout(() => {\n        open();\n      }, delayMs);\n    };\n\n    const open = () => {\n      if (subscription.stopped) return;\n      if (subscription.retryTimer) {\n        clearTimeout(subscription.retryTimer);\n        subscription.retryTimer = null;\n      }\n      if (subscription.eventSource) {\n        subscription.eventSource.close();\n      }\n\n      const updatesEventSource = new EventSource(updatesUrlString);\n      subscription.eventSource = updatesEventSource;\n\n      console.log(\"[SSE] subscribed\", updatesUrlString);\n\n      updatesEventSource.onopen = () => {\n        subscription.retries = 0;\n        console.log(\"[SSE] open\", updatesUrlString);\n      };\n\n      updatesEventSource.onmessage = (event) => {\n        try {\n          console.log(\"[SSE] message\", { url: updatesUrlString, data: event.data });\n          const parsed = JSON.parse(event.data) as ApiSSEEvent;\n          onUpdate(parsed);\n        } catch (error) {\n          console.error(\"Failed to parse SSE event:\", error);\n          onError?.(error);\n        }\n      };\n\n      updatesEventSource.onerror = (error) => {\n        console.error(\"SSE connection error:\", {\n          url: updatesUrlString,\n          readyState: updatesEventSource.readyState,\n          error,\n        });\n        onError?.(error);\n        if (subscription.stopped) return;\n        updatesEventSource.close();\n        scheduleRetry();\n      };\n    };\n\n    this.updatesEventSources.set(sessionId, subscription);\n    open();\n\n    return () => {\n      const current = this.updatesEventSources.get(sessionId);\n      if (current === subscription) {\n        current.cleanup();\n        this.updatesEventSources.delete(sessionId);\n      } else {\n        subscription.cleanup();\n      }\n    };\n  }\n\n  async fetchThreads(publicKey: string): Promise<ApiThread[]> {\n    console.log(\"[fetchThreads] Called with publicKey:\", publicKey);\n    const url = `${this.backendUrl}/api/sessions?public_key=${encodeURIComponent(publicKey)}`;\n    console.log(\"[fetchThreads] URL:\", url);\n\n    const response = await fetch(url);\n    console.log(\"[fetchThreads] Response status:\", response.status);\n\n    if (!response.ok) {\n      console.error(\"[fetchThreads] Error:\", response.status);\n      throw new Error(`Failed to fetch threads: HTTP ${response.status}`);\n    }\n\n    const data = (await response.json()) as ApiThread[];\n    console.log(\"[fetchThreads] Success:\", data);\n    return data;\n  }\n\n  async fetchThread(sessionId: string): Promise<ApiThread> {\n    console.log(\"[fetchThread] Called with sessionId:\", sessionId);\n    const url = `${this.backendUrl}/api/sessions/${encodeURIComponent(sessionId)}`;\n    console.log(\"[fetchThread] URL:\", url);\n\n    const response = await fetch(url);\n    console.log(\"[fetchThread] Response status:\", response.status, response.statusText);\n\n    if (!response.ok) {\n      console.error(\"[fetchThread] Error:\", response.status, response.statusText);\n      throw new Error(`HTTP ${response.status}: ${response.statusText}`);\n    }\n\n    const data = (await response.json()) as ApiThread;\n    console.log(\"[fetchThread] Success:\", data);\n    return data;\n  }\n\n  async createThread(publicKey?: string, title?: string): Promise<ApiCreateThreadResponse> {\n    console.log(\"[createThread] Called with publicKey:\", publicKey, \"title:\", title);\n    const body: Record<string, string> = {};\n    if (publicKey) {\n      body.public_key = publicKey;\n    }\n    if (title) {\n      body.title = title;\n    }\n    console.log(\"[createThread] Request body:\", body);\n\n    const url = `${this.backendUrl}/api/sessions`;\n    console.log(\"[createThread] URL:\", url);\n\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify(body),\n    });\n    console.log(\"[createThread] Response status:\", response.status);\n\n    if (!response.ok) {\n      console.error(\"[createThread] Error:\", response.status);\n      throw new Error(`Failed to create thread: HTTP ${response.status}`);\n    }\n\n    const data = (await response.json()) as ApiCreateThreadResponse;\n    console.log(\"[createThread] Success:\", data);\n    return data;\n  }\n\n  async archiveThread(sessionId: string): Promise<void> {\n    console.log(\"[archiveThread] Called with sessionId:\", sessionId);\n    const url = `${this.backendUrl}/api/sessions/${encodeURIComponent(sessionId)}/archive`;\n    console.log(\"[archiveThread] URL:\", url);\n\n    const response = await fetch(url, { method: \"POST\" });\n    console.log(\"[archiveThread] Response status:\", response.status);\n\n    if (!response.ok) {\n      console.error(\"[archiveThread] Error:\", response.status);\n      throw new Error(`Failed to archive thread: HTTP ${response.status}`);\n    }\n    console.log(\"[archiveThread] Success\");\n  }\n\n  async unarchiveThread(sessionId: string): Promise<void> {\n    console.log(\"[unarchiveThread] Called with sessionId:\", sessionId);\n    const url = `${this.backendUrl}/api/sessions/${encodeURIComponent(sessionId)}/unarchive`;\n    console.log(\"[unarchiveThread] URL:\", url);\n\n    const response = await fetch(url, { method: \"POST\" });\n    console.log(\"[unarchiveThread] Response status:\", response.status);\n\n    if (!response.ok) {\n      console.error(\"[unarchiveThread] Error:\", response.status);\n      throw new Error(`Failed to unarchive thread: HTTP ${response.status}`);\n    }\n    console.log(\"[unarchiveThread] Success\");\n  }\n\n  async deleteThread(sessionId: string): Promise<void> {\n    console.log(\"[deleteThread] Called with sessionId:\", sessionId);\n    const url = `${this.backendUrl}/api/sessions/${encodeURIComponent(sessionId)}`;\n    console.log(\"[deleteThread] URL:\", url);\n\n    const response = await fetch(url, { method: \"DELETE\" });\n    console.log(\"[deleteThread] Response status:\", response.status);\n\n    if (!response.ok) {\n      console.error(\"[deleteThread] Error:\", response.status);\n      throw new Error(`Failed to delete thread: HTTP ${response.status}`);\n    }\n    console.log(\"[deleteThread] Success\");\n  }\n\n  async renameThread(sessionId: string, newTitle: string): Promise<void> {\n    console.log(\"[renameThread] Called with sessionId:\", sessionId, \"newTitle:\", newTitle);\n    const url = `${this.backendUrl}/api/sessions/${encodeURIComponent(sessionId)}`;\n    console.log(\"[renameThread] URL:\", url);\n\n    const response = await fetch(url, {\n      method: \"PATCH\",\n      headers: { \"Content-Type\": \"application/json\" },\n      body: JSON.stringify({ title: newTitle }),\n    });\n    console.log(\"[renameThread] Response status:\", response.status);\n\n    if (!response.ok) {\n      console.error(\"[renameThread] Error:\", response.status);\n      throw new Error(`Failed to rename thread: HTTP ${response.status}`);\n    }\n    console.log(\"[renameThread] Success\");\n  }\n\n  async getSystemEvents(sessionId: string): Promise<ApiSystemEvent[]> {\n    console.log(\"[getSystemEvents] Called with sessionId:\", sessionId);\n    const url = `${this.backendUrl}/api/events?session_id=${encodeURIComponent(sessionId)}`;\n    console.log(\"[getSystemEvents] URL:\", url);\n\n    const response = await fetch(url);\n    console.log(\"[getSystemEvents] Response status:\", response.status);\n\n    if (!response.ok) {\n      if (response.status === 404) {\n        // Session doesn't exist yet, return empty array\n        console.log(\"[getSystemEvents] Session not found, returning empty\");\n        return [];\n      }\n      console.error(\"[getSystemEvents] Error:\", response.status);\n      throw new Error(`Failed to get system events: HTTP ${response.status}`);\n    }\n\n    const data = (await response.json()) as ApiSystemEvent[];\n    console.log(\"[getSystemEvents] Success:\", data);\n    return data;\n  }\n\n  /**\n   * Fetch events after a specific event ID (for pagination/cursor-based fetching).\n   */\n  async fetchEventsAfter(\n    sessionId: string,\n    afterId = 0,\n    limit = 100\n  ): Promise<ApiSystemEvent[]> {\n    const url = new URL(\"/api/events\", this.backendUrl);\n    url.searchParams.set(\"session_id\", sessionId);\n    if (afterId > 0) url.searchParams.set(\"after_id\", String(afterId));\n    if (limit) url.searchParams.set(\"limit\", String(limit));\n\n    console.log(\"[fetchEventsAfter] URL:\", url.toString());\n\n    const response = await fetch(url.toString());\n    if (!response.ok) {\n      throw new Error(`Failed to fetch events: HTTP ${response.status}`);\n    }\n    return (await response.json()) as ApiSystemEvent[];\n  }\n}\n","\"use client\";\n\nimport { useEffect, useMemo, useRef } from \"react\";\nimport type { ReactNode } from \"react\";\nimport {\n  AssistantRuntimeProvider,\n  type ExternalStoreThreadData,\n  useExternalStoreRuntime,\n  type AppendMessage,\n} from \"@assistant-ui/react\";\n\nimport { EventContextProvider } from \"../contexts/event-context\";\nimport { useRuntimeOrchestrator } from \"./orchestrator\";\nimport {\n  findTempIdForBackendId,\n  isThreadReady,\n  isThreadRunning,\n  markSkipInitialFetch,\n  resolveThreadId,\n  setBackendMapping,\n} from \"../state/backend-state\";\nimport { isPlaceholderTitle, isTempThreadId, parseTimestamp } from \"./utils\";\nimport { useThreadContext } from \"../contexts/thread-context\";\nimport { ThreadMetadata } from \"../state/thread-store\";\n\nconst sortByLastActiveDesc = (\n  [, metaA]: [string, ThreadMetadata],\n  [, metaB]: [string, ThreadMetadata]\n) => {\n  const tsA = parseTimestamp(metaA.lastActiveAt);\n  const tsB = parseTimestamp(metaB.lastActiveAt);\n  return tsB - tsA;\n};\n\nfunction buildThreadLists(threadMetadata: Map<string, ThreadMetadata>) {\n  const entries = Array.from(threadMetadata.entries()).filter(\n    ([, meta]) => !isPlaceholderTitle(meta.title)\n  );\n\n  const regularThreads = entries\n    .filter(([, meta]) => meta.status === \"regular\")\n    .sort(sortByLastActiveDesc)\n    .map(([id, meta]): ExternalStoreThreadData<\"regular\"> => ({\n      id,\n      title: meta.title || \"New Chat\",\n      status: \"regular\",\n    }));\n\n  const archivedThreads = entries\n    .filter(([, meta]) => meta.status === \"archived\")\n    .sort(sortByLastActiveDesc)\n    .map(([id, meta]): ExternalStoreThreadData<\"archived\"> => ({\n      id,\n      title: meta.title || \"New Chat\",\n      status: \"archived\",\n    }));\n\n  return { regularThreads, archivedThreads };\n}\n\nexport type AomiRuntimeProviderProps = {\n  children: ReactNode;\n  backendUrl?: string;\n  publicKey?: string;\n};\n\nexport function AomiRuntimeProvider({\n  children,\n  backendUrl = \"http://localhost:8080\",\n  publicKey,\n}: Readonly<AomiRuntimeProviderProps>) {\n  const threadContext = useThreadContext();\n  const {\n    backendStateRef,\n    polling,\n    messageController,\n    isRunning,\n    setIsRunning,\n    ensureInitialState,\n    backendApiRef,\n  } = useRuntimeOrchestrator(backendUrl);\n\n  const threadContextRef = useRef(threadContext);\n  threadContextRef.current = threadContext;\n\n  const currentThreadIdRef = useRef(threadContext.currentThreadId);\n  useEffect(() => {\n    currentThreadIdRef.current = threadContext.currentThreadId;\n  }, [threadContext.currentThreadId]);\n\n  useEffect(() => {\n    void ensureInitialState(threadContext.currentThreadId);\n  }, [ensureInitialState, threadContext.currentThreadId]);\n\n  useEffect(() => {\n    const threadId = threadContext.currentThreadId;\n    setIsRunning(isThreadRunning(backendStateRef.current, threadId));\n  }, [backendStateRef, setIsRunning, threadContext.currentThreadId]);\n\n  const currentMessages = threadContext.getThreadMessages(threadContext.currentThreadId);\n\n  // Fetch thread list on mount when publicKey is available\n  useEffect(() => {\n    if (!publicKey) return;\n\n    const fetchThreadList = async () => {\n      try {\n        const threadList = await backendApiRef.current.fetchThreads(publicKey);\n        const currentContext = threadContextRef.current;\n        const newMetadata = new Map(currentContext.threadMetadata);\n        let maxChatNum = currentContext.threadCnt;\n\n        for (const thread of threadList) {\n          const rawTitle = thread.title ?? \"\";\n          const title = isPlaceholderTitle(rawTitle) ? \"\" : rawTitle;\n          const lastActive =\n            thread.last_active_at ||\n            thread.updated_at ||\n            thread.created_at ||\n            newMetadata.get(thread.session_id)?.lastActiveAt ||\n            new Date().toISOString();\n          newMetadata.set(thread.session_id, {\n            title,\n            status: thread.is_archived ? \"archived\" : \"regular\",\n            lastActiveAt: lastActive,\n          });\n\n          const match = title.match(/^Chat (\\d+)$/);\n          if (match) {\n            const num = parseInt(match[1], 10);\n            if (num > maxChatNum) {\n              maxChatNum = num;\n            }\n          }\n        }\n\n        currentContext.setThreadMetadata(newMetadata);\n        if (maxChatNum > currentContext.threadCnt) {\n          currentContext.setThreadCnt(maxChatNum);\n        }\n      } catch (error) {\n        console.error(\"Failed to fetch thread list:\", error);\n      }\n    };\n\n    void fetchThreadList();\n  }, [publicKey, backendApiRef]);\n\n  const threadListAdapter = useMemo(() => {\n    const backendState = backendStateRef.current;\n    const { regularThreads, archivedThreads } = buildThreadLists(threadContext.threadMetadata);\n\n    const preparePendingThread = (threadId: string) => {\n      const previousPendingId = backendState.creatingThreadId;\n      if (previousPendingId && previousPendingId !== threadId) {\n        threadContext.setThreadMetadata((prev) => {\n          const next = new Map(prev);\n          next.delete(previousPendingId);\n          return next;\n        });\n        threadContext.setThreads((prev) => {\n          const next = new Map(prev);\n          next.delete(previousPendingId);\n          return next;\n        });\n        backendState.pendingChat.delete(previousPendingId);\n        backendState.tempToBackendId.delete(previousPendingId);\n        backendState.skipInitialFetch.delete(previousPendingId);\n      }\n      backendState.creatingThreadId = threadId;\n      backendState.pendingChat.delete(threadId);\n      threadContext.setThreadMetadata((prev) =>\n        new Map(prev).set(threadId, {\n          title: \"New Chat\",\n          status: \"pending\",\n          lastActiveAt: new Date().toISOString(),\n        })\n      );\n      threadContext.setThreadMessages(threadId, []);\n      threadContext.setCurrentThreadId(threadId);\n      setIsRunning(false);\n      threadContext.bumpThreadViewKey();\n    };\n\n    const findPendingThreadId = () => {\n      if (backendState.creatingThreadId) return backendState.creatingThreadId;\n      for (const [id, meta] of threadContext.threadMetadata.entries()) {\n        if (meta.status === \"pending\") return id;\n      }\n      return null;\n    };\n\n    return {\n      threadId: threadContext.currentThreadId,\n      threads: regularThreads,\n      archivedThreads,\n\n      onSwitchToNewThread: async () => {\n        const pendingId = findPendingThreadId();\n        if (pendingId) {\n          preparePendingThread(pendingId);\n          return;\n        }\n\n        if (backendState.createThreadPromise) {\n          preparePendingThread(backendState.creatingThreadId ?? `temp-${crypto.randomUUID()}`);\n          return;\n        }\n\n        const tempId = `temp-${crypto.randomUUID()}`;\n        preparePendingThread(tempId);\n\n        const createPromise = backendApiRef.current\n          .createThread(publicKey, undefined)\n          .then(async (newThread) => {\n            const uiThreadId = backendState.creatingThreadId ?? tempId;\n            const backendId = newThread.session_id;\n\n            setBackendMapping(backendState, uiThreadId, backendId);\n            markSkipInitialFetch(backendState, uiThreadId);\n\n            const backendTitle = newThread.title;\n            if (backendTitle && !isPlaceholderTitle(backendTitle)) {\n              threadContext.setThreadMetadata((prev) => {\n                const next = new Map(prev);\n                const existing = next.get(uiThreadId);\n                const nextStatus = existing?.status === \"archived\" ? \"archived\" : \"regular\";\n                next.set(uiThreadId, {\n                  title: backendTitle,\n                  status: nextStatus,\n                  lastActiveAt: existing?.lastActiveAt ?? new Date().toISOString(),\n                });\n                return next;\n              });\n            }\n\n            if (backendState.creatingThreadId === uiThreadId) {\n              backendState.creatingThreadId = null;\n            }\n\n            const pendingMessages = backendState.pendingChat.get(uiThreadId);\n            if (pendingMessages?.length) {\n              backendState.pendingChat.delete(uiThreadId);\n              for (const text of pendingMessages) {\n                try {\n                  await backendApiRef.current.postChatMessage(backendId, text);\n                } catch (error) {\n                  console.error(\"Failed to send queued message:\", error);\n                }\n              }\n              if (currentThreadIdRef.current === uiThreadId) {\n                polling?.start(uiThreadId);\n              }\n            }\n          })\n          .catch((error) => {\n            console.error(\"Failed to create new thread:\", error);\n            const failedId = backendState.creatingThreadId ?? tempId;\n            threadContext.setThreadMetadata((prev) => {\n              const next = new Map(prev);\n              next.delete(failedId);\n              return next;\n            });\n            threadContext.setThreads((prev) => {\n              const next = new Map(prev);\n              next.delete(failedId);\n              return next;\n            });\n            if (backendState.creatingThreadId === failedId) {\n              backendState.creatingThreadId = null;\n            }\n          })\n          .finally(() => {\n            backendState.createThreadPromise = null;\n          });\n\n        backendState.createThreadPromise = createPromise;\n      },\n\n      onSwitchToThread: (threadId: string) => {\n        threadContext.setCurrentThreadId(threadId);\n      },\n\n      onRename: async (threadId: string, newTitle: string) => {\n        const previousTitle = threadContext.getThreadMetadata(threadId)?.title ?? \"\";\n        const normalizedTitle = isPlaceholderTitle(newTitle) ? \"\" : newTitle;\n        threadContext.updateThreadMetadata(threadId, {\n          title: normalizedTitle,\n        });\n\n        try {\n          await backendApiRef.current.renameThread(threadId, newTitle);\n        } catch (error) {\n          console.error(\"Failed to rename thread:\", error);\n          threadContext.updateThreadMetadata(threadId, { title: previousTitle });\n        }\n      },\n\n      onArchive: async (threadId: string) => {\n        threadContext.updateThreadMetadata(threadId, { status: \"archived\" });\n\n        try {\n          await backendApiRef.current.archiveThread(threadId);\n        } catch (error) {\n          console.error(\"Failed to archive thread:\", error);\n          threadContext.updateThreadMetadata(threadId, { status: \"regular\" });\n        }\n      },\n\n      onUnarchive: async (threadId: string) => {\n        threadContext.updateThreadMetadata(threadId, { status: \"regular\" });\n\n        try {\n          await backendApiRef.current.unarchiveThread(threadId);\n        } catch (error) {\n          console.error(\"Failed to unarchive thread:\", error);\n          threadContext.updateThreadMetadata(threadId, { status: \"archived\" });\n        }\n      },\n\n      onDelete: async (threadId: string) => {\n        try {\n          await backendApiRef.current.deleteThread(threadId);\n\n          threadContext.setThreadMetadata((prev) => {\n            const next = new Map(prev);\n            next.delete(threadId);\n            return next;\n          });\n          threadContext.setThreads((prev) => {\n            const next = new Map(prev);\n            next.delete(threadId);\n            return next;\n          });\n          backendState.pendingChat.delete(threadId);\n          backendState.tempToBackendId.delete(threadId);\n          backendState.skipInitialFetch.delete(threadId);\n          backendState.runningThreads.delete(threadId);\n          if (backendState.creatingThreadId === threadId) {\n            backendState.creatingThreadId = null;\n          }\n\n          if (threadContext.currentThreadId === threadId) {\n            const firstRegularThread = Array.from(threadContext.threadMetadata.entries()).find(\n              ([id, meta]) => meta.status === \"regular\" && id !== threadId\n            );\n\n            if (firstRegularThread) {\n              threadContext.setCurrentThreadId(firstRegularThread[0]);\n            } else {\n              const defaultId = \"default-session\";\n              threadContext.setThreadMetadata((prev) =>\n                new Map(prev).set(defaultId, {\n                  title: \"New Chat\",\n                  status: \"regular\",\n                  lastActiveAt: new Date().toISOString(),\n                })\n              );\n              threadContext.setThreadMessages(defaultId, []);\n              threadContext.setCurrentThreadId(defaultId);\n            }\n          }\n        } catch (error) {\n          console.error(\"Failed to delete thread:\", error);\n          throw error;\n        }\n      },\n    };\n  }, [\n    backendApiRef,\n    polling,\n    publicKey,\n    backendStateRef,\n    setIsRunning,\n    threadContext,\n    threadContext.currentThreadId,\n    threadContext.threadMetadata,\n  ]);\n\n  // Subscribe to SSE updates for title changes\n  useEffect(() => {\n    const currentSessionId = threadContext.currentThreadId;\n    const unsubscribe = backendApiRef.current.subscribeSSE(\n      currentSessionId,\n      (event) => {\n        const eventType = event.type as string;\n        const sessionId = event.session_id;\n\n        if (eventType === \"title_changed\") {\n          const newTitle = event.new_title as string;\n          const backendState = backendStateRef.current;\n          const targetThreadId =\n            findTempIdForBackendId(backendState, sessionId) ??\n            resolveThreadId(backendState, sessionId);\n          const normalizedTitle = isPlaceholderTitle(newTitle) ? \"\" : newTitle;\n          threadContext.setThreadMetadata((prev) => {\n            const next = new Map(prev);\n            const existing = next.get(targetThreadId);\n            const nextStatus = existing?.status === \"archived\" ? \"archived\" : \"regular\";\n            next.set(targetThreadId, {\n              title: normalizedTitle,\n              status: nextStatus,\n              lastActiveAt: existing?.lastActiveAt ?? new Date().toISOString(),\n            });\n            return next;\n          });\n          if (!isPlaceholderTitle(newTitle) && backendState.creatingThreadId === targetThreadId) {\n            backendState.creatingThreadId = null;\n          }\n        }\n        // Other event types (wallet:tx_request, notification, etc.) are handled\n        // by the EventContext and dispatched to subscribers\n      }\n    );\n\n    return () => {\n      unsubscribe?.();\n    };\n  }, [backendApiRef, backendStateRef, threadContext, threadContext.currentThreadId]);\n\n  // Flush pending chat when thread becomes ready\n  useEffect(() => {\n    const threadId = threadContext.currentThreadId;\n    if (!isTempThreadId(threadId)) return;\n    if (!isThreadReady(backendStateRef.current, threadId)) return;\n    void messageController.flushPendingChat(threadId);\n  }, [messageController, backendStateRef, threadContext.currentThreadId]);\n\n  const runtime = useExternalStoreRuntime({\n    messages: currentMessages,\n    setMessages: (msgs) =>\n      threadContext.setThreadMessages(threadContext.currentThreadId, [...msgs]),\n    isRunning,\n    onNew: (message: AppendMessage) =>\n      messageController.outbound(message, threadContext.currentThreadId),\n    onCancel: () => messageController.cancel(threadContext.currentThreadId),\n    convertMessage: (msg) => msg,\n    adapters: { threadList: threadListAdapter },\n  });\n\n  useEffect(() => {\n    return () => {\n      polling.stopAll();\n    };\n  }, [polling]);\n\n  return (\n    <EventContextProvider\n      backendApi={backendApiRef.current}\n      sessionId={threadContext.currentThreadId}\n    >\n      <AssistantRuntimeProvider runtime={runtime}>{children}</AssistantRuntimeProvider>\n    </EventContextProvider>\n  );\n}\n","\"use client\";\n\nimport {\n  createContext,\n  useCallback,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n} from \"react\";\nimport type { ReactNode } from \"react\";\n\nimport type { BackendApi } from \"../backend/client\";\nimport type { ApiSSEEvent } from \"../backend/types\";\nimport {\n  createEventBuffer,\n  dispatch,\n  enqueueInbound,\n  setSSEStatus,\n  subscribe as subscribeToBuffer,\n  type EventBuffer,\n  type EventSubscriber,\n  type InboundEvent,\n  type OutboundEvent,\n  type SSEStatus,\n} from \"../state/event-buffer\";\n\n// =============================================================================\n// Context Type\n// =============================================================================\n\nexport type EventContext = {\n  /** Subscribe to inbound events by type. Returns unsubscribe function. */\n  subscribe: (type: string, callback: EventSubscriber) => () => void;\n  /** Send an outbound event to backend immediately */\n  sendOutbound: (event: Omit<OutboundEvent, \"timestamp\">) => void;\n  /** Current SSE connection status */\n  sseStatus: SSEStatus;\n};\n\nconst EventContextState = createContext<EventContext | null>(null);\n\n// =============================================================================\n// Hook\n// =============================================================================\n\nexport function useEventContext(): EventContext {\n  const context = useContext(EventContextState);\n  if (!context) {\n    throw new Error(\n      \"useEventContext must be used within EventContextProvider. \" +\n        \"Wrap your app with <EventContextProvider>...</EventContextProvider>\"\n    );\n  }\n  return context;\n}\n\n// =============================================================================\n// Provider Props\n// =============================================================================\n\nexport type EventContextProviderProps = {\n  children: ReactNode;\n  backendApi: BackendApi;\n  sessionId: string;\n};\n\n// =============================================================================\n// Provider\n// =============================================================================\n\nexport function EventContextProvider({\n  children,\n  backendApi,\n  sessionId,\n}: EventContextProviderProps) {\n  const bufferRef = useRef<EventBuffer | null>(null);\n  if (!bufferRef.current) {\n    bufferRef.current = createEventBuffer();\n  }\n  const buffer = bufferRef.current;\n\n  const [sseStatus, setSseStatus] = useState<SSEStatus>(\"disconnected\");\n\n  // ---------------------------------------------------------------------------\n  // SSE Subscription (reconnects when sessionId changes)\n  // ---------------------------------------------------------------------------\n  useEffect(() => {\n    setSSEStatus(buffer, \"connecting\");\n    setSseStatus(\"connecting\");\n\n    const unsubscribe = backendApi.subscribeSSE(\n      sessionId,\n      (event: ApiSSEEvent) => {\n        enqueueInbound(buffer, {\n          type: event.type,\n          sessionId: event.session_id,\n          payload: event,\n        });\n\n        const inboundEvent: InboundEvent = {\n          type: event.type,\n          sessionId: event.session_id,\n          payload: event,\n          status: \"fetched\",\n          timestamp: Date.now(),\n        };\n        dispatch(buffer, inboundEvent);\n      },\n      (error) => {\n        console.error(\"SSE error:\", error);\n        setSSEStatus(buffer, \"disconnected\");\n        setSseStatus(\"disconnected\");\n      }\n    );\n\n    setSSEStatus(buffer, \"connected\");\n    setSseStatus(\"connected\");\n\n    return () => {\n      unsubscribe();\n      setSSEStatus(buffer, \"disconnected\");\n      setSseStatus(\"disconnected\");\n    };\n  }, [backendApi, buffer, sessionId]);\n\n  // ---------------------------------------------------------------------------\n  // Context Value\n  // ---------------------------------------------------------------------------\n  const subscribeCallback = useCallback(\n    (type: string, callback: EventSubscriber) => {\n      return subscribeToBuffer(buffer, type, callback);\n    },\n    [buffer]\n  );\n\n  const sendOutbound = useCallback(\n    async (event: Omit<OutboundEvent, \"timestamp\">) => {\n      try {\n        const message = JSON.stringify({\n          type: event.type,\n          payload: event.payload,\n        });\n        await backendApi.postSystemMessage(event.sessionId, message);\n      } catch (error) {\n        console.error(\"Failed to send outbound event:\", error);\n      }\n    },\n    [backendApi]\n  );\n\n  const contextValue: EventContext = {\n    subscribe: subscribeCallback,\n    sendOutbound,\n    sseStatus,\n  };\n\n  return (\n    <EventContextState.Provider value={contextValue}>\n      {children}\n    </EventContextState.Provider>\n  );\n}\n","\nexport type InboundEvent = {\n  type: string;\n  sessionId: string;\n  payload?: unknown;\n  status: \"pending\" | \"fetched\";\n  timestamp: number;\n};\n\nexport type OutboundEvent = {\n  type: string;\n  sessionId: string;\n  payload: unknown;\n  priority: \"high\" | \"normal\";\n  timestamp: number;\n};\n\nexport type SSEStatus = \"connected\" | \"connecting\" | \"disconnected\";\n\nexport type EventSubscriber = (event: InboundEvent) => void;\n\n\nexport type EventBuffer = {\n  inboundQueue: InboundEvent[];\n  outboundQueue: OutboundEvent[];\n  sseStatus: SSEStatus;\n  lastEventId: string | null;\n  subscribers: Map<string, Set<EventSubscriber>>;\n};\n\nexport function createEventBuffer(): EventBuffer {\n  return {\n    inboundQueue: [],\n    outboundQueue: [],\n    sseStatus: \"disconnected\",\n    lastEventId: null,\n    subscribers: new Map(),\n  };\n}\n\n// =============================================================================\n// Inbound Queue Helpers\n// =============================================================================\n\nexport function enqueueInbound(\n  state: EventBuffer,\n  event: Omit<InboundEvent, \"status\" | \"timestamp\">\n): void {\n  state.inboundQueue.push({\n    ...event,\n    status: \"pending\",\n    timestamp: Date.now(),\n  });\n}\n\nexport function dequeueInbound(state: EventBuffer): InboundEvent | null {\n  return state.inboundQueue.shift() ?? null;\n}\n\nexport function peekInbound(state: EventBuffer): InboundEvent | null {\n  return state.inboundQueue[0] ?? null;\n}\n\nexport function markFetched(\n  state: EventBuffer,\n  event: InboundEvent,\n  payload: unknown\n): void {\n  event.status = \"fetched\";\n  event.payload = payload;\n}\n\nexport function hasInbound(state: EventBuffer): boolean {\n  return state.inboundQueue.length > 0;\n}\n\n// =============================================================================\n// Outbound Queue Helpers\n// =============================================================================\n\nexport function enqueueOutbound(\n  state: EventBuffer,\n  event: Omit<OutboundEvent, \"timestamp\">\n): void {\n  state.outboundQueue.push({\n    ...event,\n    timestamp: Date.now(),\n  });\n}\n\nexport function drainOutbound(state: EventBuffer): OutboundEvent[] {\n  const events = [...state.outboundQueue];\n  state.outboundQueue = [];\n  return events;\n}\n\nexport function hasOutbound(state: EventBuffer): boolean {\n  return state.outboundQueue.length > 0;\n}\n\nexport function hasHighPriorityOutbound(state: EventBuffer): boolean {\n  return state.outboundQueue.some((e) => e.priority === \"high\");\n}\n\n// =============================================================================\n// Subscription Helpers\n// =============================================================================\n\nexport function subscribe(\n  state: EventBuffer,\n  type: string,\n  callback: EventSubscriber\n): () => void {\n  if (!state.subscribers.has(type)) {\n    state.subscribers.set(type, new Set());\n  }\n  state.subscribers.get(type)!.add(callback);\n\n  // Return unsubscribe function\n  return () => {\n    state.subscribers.get(type)?.delete(callback);\n  };\n}\n\nexport function subscribeAll(\n  state: EventBuffer,\n  callback: EventSubscriber\n): () => void {\n  return subscribe(state, \"*\", callback);\n}\n\nexport function dispatch(state: EventBuffer, event: InboundEvent): void {\n  // Dispatch to specific type subscribers\n  const typeSubscribers = state.subscribers.get(event.type);\n  if (typeSubscribers) {\n    for (const callback of typeSubscribers) {\n      callback(event);\n    }\n  }\n\n  // Dispatch to wildcard subscribers\n  const allSubscribers = state.subscribers.get(\"*\");\n  if (allSubscribers) {\n    for (const callback of allSubscribers) {\n      callback(event);\n    }\n  }\n}\n\n// =============================================================================\n// SSE Status Helpers\n// =============================================================================\n\nexport function setSSEStatus(state: EventBuffer, status: SSEStatus): void {\n  state.sseStatus = status;\n}\n\nexport function setLastEventId(state: EventBuffer, id: string): void {\n  state.lastEventId = id;\n}\n","import type { MutableRefObject } from \"react\";\nimport { useCallback, useEffect, useRef, useState } from \"react\";\n\nimport { BackendApi } from \"../backend/client\";\nimport type { AomiMessage } from \"../backend/types\";\nimport { useThreadContext, type ThreadContext } from \"../contexts/thread-context\";\nimport { MessageController } from \"./message-controller\";\nimport { PollingController } from \"./polling-controller\";\nimport {\n  clearSkipInitialFetch,\n  createBakendState,\n  isThreadReady,\n  resolveThreadId,\n  shouldSkipInitialFetch,\n  type BakendState,\n} from \"../state/backend-state\";\n\ntype SystemEventsHandler = (\n  sessionId: string,\n  threadId: string,\n  events?: unknown[] | null\n) => void;\n\nexport function useRuntimeOrchestrator(\n  backendUrl: string,\n  options?: { getPublicKey?: () => string | undefined }\n) {\n  const threadContext = useThreadContext();\n  const threadContextRef = useRef<ThreadContext>(threadContext);\n  threadContextRef.current = threadContext;\n  const backendApiRef = useRef(new BackendApi(backendUrl));\n  const backendStateRef = useRef<BakendState>(createBakendState());\n\n  const [isRunning, setIsRunning] = useState(false);\n\n  const messageControllerRef: MutableRefObject<MessageController | null> = useRef(null);\n  const pollingRef: MutableRefObject<PollingController | null> = useRef(null);\n  const systemEventsHandlerRef = useRef<SystemEventsHandler | null>(null);\n  const inFlightRef = useRef<Map<string, AbortController>>(new Map());\n\n  if (!pollingRef.current) {\n    pollingRef.current = new PollingController({\n      backendApiRef,\n      backendStateRef,\n      applyMessages: (threadId: string, msgs?: AomiMessage[] | null) => {\n        messageControllerRef.current?.inbound(threadId, msgs);\n      },\n      onStart: (threadId: string) => {\n        if (threadContextRef.current.currentThreadId === threadId) {\n          setIsRunning(true);\n        }\n      },\n      onStop: (threadId: string) => {\n        if (threadContextRef.current.currentThreadId === threadId) {\n          setIsRunning(false);\n        }\n      },\n    });\n  }\n\n  if (!messageControllerRef.current) {\n    messageControllerRef.current = new MessageController({\n      backendApiRef,\n      backendStateRef,\n      threadContextRef,\n      polling: pollingRef.current,\n      setGlobalIsRunning: setIsRunning,\n      getPublicKey: options?.getPublicKey,\n    });\n  }\n\n  const setSystemEventsHandler = useCallback((handler: SystemEventsHandler | null) => {\n    systemEventsHandlerRef.current = handler;\n    pollingRef.current?.setSystemEventsHandler(handler ?? undefined);\n  }, []);\n\n  useEffect(() => {\n    return () => {\n      for (const controller of inFlightRef.current.values()) {\n        controller.abort();\n      }\n      inFlightRef.current.clear();\n    };\n  }, []);\n\n  const ensureInitialState = useCallback(\n    async (threadId: string) => {\n      const backendState = backendStateRef.current;\n      if (shouldSkipInitialFetch(backendState, threadId)) {\n        clearSkipInitialFetch(backendState, threadId);\n        if (threadContextRef.current.currentThreadId === threadId) {\n          setIsRunning(false);\n        }\n        return;\n      }\n\n      if (!isThreadReady(backendState, threadId)) {\n        if (threadContextRef.current.currentThreadId === threadId) {\n          setIsRunning(false);\n        }\n        return;\n      }\n\n      if (inFlightRef.current.has(threadId)) {\n        return;\n      }\n\n      const backendThreadId = resolveThreadId(backendState, threadId);\n      const controller = new AbortController();\n      inFlightRef.current.set(threadId, controller);\n      try {\n        console.log(\"[Orchestrator] Fetching initial state for threadId:\", threadId);\n        const state = await backendApiRef.current.fetchState(backendThreadId, {\n          signal: controller.signal,\n        });\n        messageControllerRef.current?.inbound(threadId, state.messages);\n        if (state.is_processing) {\n          if (threadContextRef.current.currentThreadId === threadId) {\n            setIsRunning(true);\n          }\n          pollingRef.current?.start(threadId);\n        } else {\n          if (threadContextRef.current.currentThreadId === threadId) {\n            setIsRunning(false);\n          }\n        }\n      } catch (error) {\n        if (controller.signal.aborted) {\n          return;\n        }\n        console.error(\"Failed to fetch initial state:\", error);\n        if (threadContextRef.current.currentThreadId === threadId) {\n          setIsRunning(false);\n        }\n      } finally {\n        if (inFlightRef.current.get(threadId) === controller) {\n          inFlightRef.current.delete(threadId);\n        }\n      }\n    },\n    [backendApiRef, backendStateRef, pollingRef, messageControllerRef, setIsRunning]\n  );\n\n  return {\n    backendStateRef,\n    polling: pollingRef.current!,\n    messageController: messageControllerRef.current!,\n    isRunning,\n    setIsRunning,\n    ensureInitialState,\n    setSystemEventsHandler,\n    backendApiRef,\n  };\n}\n","\"use client\";\n\nimport { createContext, useContext, useMemo, useRef, useSyncExternalStore } from \"react\";\nimport type { ReactNode, SetStateAction } from \"react\";\nimport type { ThreadMessageLike } from \"@assistant-ui/react\";\nimport { ThreadMetadata, ThreadStore } from \"../state/thread-store\";\n\n\nexport type ThreadContext = {\n  currentThreadId: string;\n  setCurrentThreadId: (id: string) => void;\n  threadViewKey: number;\n  bumpThreadViewKey: () => void;\n  threads: Map<string, ThreadMessageLike[]>;\n  setThreads: (updater: SetStateAction<Map<string, ThreadMessageLike[]>>) => void;\n  threadMetadata: Map<string, ThreadMetadata>;\n  setThreadMetadata: (updater: SetStateAction<Map<string, ThreadMetadata>>) => void;\n  threadCnt: number;\n  setThreadCnt: (updater: SetStateAction<number>) => void;\n  getThreadMessages: (threadId: string) => ThreadMessageLike[];\n  setThreadMessages: (threadId: string, messages: ThreadMessageLike[]) => void;\n  getThreadMetadata: (threadId: string) => ThreadMetadata | undefined;\n  updateThreadMetadata: (threadId: string, updates: Partial<ThreadMetadata>) => void;\n};\n\n\n\nexport type ThreadContextProviderProps = {\n  children: ReactNode;\n  initialThreadId?: string;\n};\n\nconst ThreadContextState = createContext<ThreadContext | null>(null);\n\nexport function useThreadContext(): ThreadContext {\n  const context = useContext(ThreadContextState);\n  if (!context) {\n    throw new Error(\n      \"useThreadContext must be used within ThreadContextProvider. \" +\n        \"Wrap your app with <ThreadContextProvider>...</ThreadContextProvider>\"\n    );\n  }\n  return context;\n}\n\nexport function ThreadContextProvider({\n  children,\n  initialThreadId,\n}: ThreadContextProviderProps) {\n  const storeRef = useRef<ThreadStore | null>(null);\n  if (!storeRef.current) {\n    storeRef.current = new ThreadStore({ initialThreadId });\n  }\n  const store = storeRef.current;\n  const value = useSyncExternalStore(store.subscribe, store.getSnapshot, store.getSnapshot);\n\n  return (\n    <ThreadContextState.Provider value={value}>{children}</ThreadContextState.Provider>\n  );\n}\n\nexport function useCurrentThreadMessages(): ThreadMessageLike[] {\n  const { currentThreadId, getThreadMessages } = useThreadContext();\n  return useMemo(() => getThreadMessages(currentThreadId), [currentThreadId, getThreadMessages]);\n}\n\nexport function useCurrentThreadMetadata(): ThreadMetadata | undefined {\n  const { currentThreadId, getThreadMetadata } = useThreadContext();\n  return useMemo(() => getThreadMetadata(currentThreadId), [currentThreadId, getThreadMetadata]);\n}\n","import type { ThreadMessageLike } from \"@assistant-ui/react\";\n\nimport type { AomiMessage } from \"../backend/types\";\nimport type { UserState } from \"../contexts/user-context\";\n\n// ==================== Thread Utilities ====================\n\nexport const isTempThreadId = (id: string) => id.startsWith(\"temp-\");\n\nexport const parseTimestamp = (value?: string | number) => {\n  if (value === undefined || value === null) return 0;\n  if (typeof value === \"number\") {\n    return Number.isFinite(value) ? (value < 1e12 ? value * 1000 : value) : 0;\n  }\n\n  const numeric = Number(value);\n  if (!Number.isNaN(numeric)) {\n    return numeric < 1e12 ? numeric * 1000 : numeric;\n  }\n\n  const ts = Date.parse(value);\n  return Number.isNaN(ts) ? 0 : ts;\n};\n\nexport const isPlaceholderTitle = (title?: string) => {\n  const normalized = title?.trim() ?? \"\";\n  return !normalized || normalized.startsWith(\"#[\");\n};\n\n// ==================== Message Conversion ====================\n\ntype MessageContentPart = Exclude<\n  ThreadMessageLike[\"content\"],\n  string\n> extends readonly (infer U)[]\n  ? U\n  : never;\n\nexport function toInboundMessage(\n  msg: AomiMessage,\n): ThreadMessageLike | null {\n  if (msg.sender === \"system\") return null;\n\n  const content: MessageContentPart[] = [];\n  const role: ThreadMessageLike[\"role\"] =\n    msg.sender === \"user\" ? \"user\" : \"assistant\";\n\n  if (msg.content) {\n    content.push({ type: \"text\" as const, text: msg.content });\n  }\n\n  // Sync result or Asnyc Ack\n  const [topic, toolContent] = parseToolResult(msg.tool_result) ?? [];\n  if (topic && toolContent) {\n    content.push({\n      type: \"tool-call\" as const,\n      toolCallId: `tool_${Date.now()}`,\n      toolName: topic,\n      args: undefined,\n      result: (() => {\n        try {\n          return JSON.parse(toolContent);\n        } catch {\n          return { args: toolContent };\n        }\n      })(),\n    });\n  }\n\n  const threadMessage = {\n    role,\n    content: (content.length > 0\n      ? content\n      : [{ type: \"text\" as const, text: \"\" }]) as ThreadMessageLike[\"content\"],\n    ...(msg.timestamp && { createdAt: new Date(msg.timestamp) }),\n  } satisfies ThreadMessageLike;\n\n  return threadMessage;\n}\n\n\nexport function constructUITool(): string {\n  return \"\";\n}\n\nfunction parseMessageTimestamp(timestamp?: string) {\n  if (!timestamp) return undefined;\n  const parsed = new Date(timestamp);\n  return Number.isNaN(parsed.valueOf()) ? undefined : parsed;\n}\n\nfunction parseToolResult(\n  toolResult: AomiMessage[\"tool_result\"],\n): [string, string] | null {\n  if (!toolResult) return null;\n\n  if (Array.isArray(toolResult) && toolResult.length === 2) {\n    const [topic, content] = toolResult;\n    return [String(topic), content];\n  }\n\n  if (typeof toolResult === \"object\") {\n    const topic = (toolResult as { topic?: unknown }).topic;\n    const content = (toolResult as { content?: unknown }).content;\n    return topic ? [String(topic), String(content)] : null;\n  }\n\n  return null;\n}\n\n// ==================== Wallet Utilities ====================\n\n/**\n * Props for wallet footer components.\n * @deprecated Use useUser() hook instead for global state access.\n */\nexport type WalletFooterProps = {\n  user: UserState;\n  setUser: (data: Partial<UserState>) => void;\n};\n\nexport type Eip1193Provider = {\n  request: (args: { method: string; params?: unknown[] }) => Promise<unknown>;\n};\n\nexport const getNetworkName = (\n  chainId: number | string | undefined,\n): string => {\n  if (chainId === undefined) return \"\";\n  const id = typeof chainId === \"string\" ? Number(chainId) : chainId;\n  switch (id) {\n    case 1:\n      return \"ethereum\";\n    case 137:\n      return \"polygon\";\n    case 42161:\n      return \"arbitrum\";\n    case 8453:\n      return \"base\";\n    case 10:\n      return \"optimism\";\n    case 11155111:\n      return \"sepolia\";\n    case 1337:\n    case 31337:\n      return \"testnet\";\n    case 59140:\n      return \"linea-sepolia\";\n    case 59144:\n      return \"linea\";\n    default:\n      return \"testnet\";\n  }\n};\n\nexport const formatAddress = (addr?: string): string =>\n  addr ? `${addr.slice(0, 6)}...${addr.slice(-4)}` : \"Connect Wallet\";\n\nexport function normalizeWalletError(error: unknown): {\n  rejected: boolean;\n  message: string;\n} {\n  const e = error as {\n    code?: unknown;\n    name?: unknown;\n    message?: unknown;\n    shortMessage?: unknown;\n    cause?: unknown;\n  };\n  const cause = (e?.cause ?? null) as {\n    code?: unknown;\n    name?: unknown;\n    message?: unknown;\n    shortMessage?: unknown;\n  } | null;\n\n  const code =\n    (typeof e?.code === \"number\" ? e.code : undefined) ??\n    (typeof cause?.code === \"number\" ? cause.code : undefined);\n  const name =\n    (typeof e?.name === \"string\" ? e.name : undefined) ??\n    (typeof cause?.name === \"string\" ? cause.name : undefined);\n  const msg =\n    (typeof e?.shortMessage === \"string\" ? e.shortMessage : undefined) ??\n    (typeof cause?.shortMessage === \"string\"\n      ? cause.shortMessage\n      : undefined) ??\n    (typeof e?.message === \"string\" ? e.message : undefined) ??\n    (typeof cause?.message === \"string\" ? cause.message : undefined) ??\n    \"Unknown wallet error\";\n\n  const rejected =\n    code === 4001 ||\n    name === \"UserRejectedRequestError\" ||\n    name === \"RejectedRequestError\" ||\n    /user rejected|rejected the request|denied|request rejected|canceled|cancelled/i.test(\n      msg,\n    );\n\n  return { rejected, message: msg };\n}\n\nexport function toHexQuantity(value: string): string {\n  const trimmed = value.trim();\n  const asBigInt = BigInt(trimmed);\n  return `0x${asBigInt.toString(16)}`;\n}\n\nexport async function pickInjectedProvider(\n  publicKey?: string,\n): Promise<Eip1193Provider | undefined> {\n  const ethereum = (globalThis as unknown as { ethereum?: unknown })\n    .ethereum as (Eip1193Provider & { providers?: unknown[] }) | undefined;\n  if (!ethereum?.request) return undefined;\n\n  const candidates: Eip1193Provider[] = Array.isArray(ethereum.providers)\n    ? (ethereum.providers.filter(\n        (p): p is Eip1193Provider => !!(p as Eip1193Provider)?.request,\n      ) as Eip1193Provider[])\n    : [ethereum];\n\n  const target = publicKey?.toLowerCase();\n  if (target) {\n    for (const candidate of candidates) {\n      try {\n        const accounts = (await candidate.request({\n          method: \"eth_accounts\",\n        })) as unknown;\n        const list = Array.isArray(accounts)\n          ? (accounts as unknown[]).map((a) => String(a).toLowerCase())\n          : [];\n        if (list.includes(target)) return candidate;\n      } catch {\n        // Ignore providers that error on eth_accounts.\n      }\n    }\n  }\n\n  return candidates[0];\n}\n","import { isTempThreadId } from \"../runtime/utils\";\n\nexport type BakendState = {\n  tempToBackendId: Map<string, string>;\n  skipInitialFetch: Set<string>;\n  pendingChat: Map<string, string[]>;\n  runningThreads: Set<string>;\n  creatingThreadId: string | null;\n  createThreadPromise: Promise<void> | null;\n};\n\nexport function createBakendState(): BakendState {\n  return {\n    tempToBackendId: new Map(),\n    skipInitialFetch: new Set(),\n    pendingChat: new Map(),\n    runningThreads: new Set(),\n    creatingThreadId: null,\n    createThreadPromise: null,\n  };\n}\n\nexport function resolveThreadId(state: BakendState, threadId: string): string {\n  return state.tempToBackendId.get(threadId) ?? threadId;\n}\n\nexport function isThreadReady(state: BakendState, threadId: string): boolean {\n  if (!isTempThreadId(threadId)) return true;\n  return state.tempToBackendId.has(threadId);\n}\n\nexport function setBackendMapping(\n  state: BakendState,\n  tempId: string,\n  backendId: string\n) {\n  state.tempToBackendId.set(tempId, backendId);\n}\n\nexport function findTempIdForBackendId(\n  state: BakendState,\n  backendId: string\n): string | undefined {\n  for (const [tempId, id] of state.tempToBackendId.entries()) {\n    if (id === backendId) return tempId;\n  }\n  return undefined;\n}\n\nexport function markSkipInitialFetch(state: BakendState, threadId: string) {\n  state.skipInitialFetch.add(threadId);\n}\n\nexport function shouldSkipInitialFetch(\n  state: BakendState,\n  threadId: string\n): boolean {\n  return state.skipInitialFetch.has(threadId);\n}\n\nexport function clearSkipInitialFetch(state: BakendState, threadId: string) {\n  state.skipInitialFetch.delete(threadId);\n}\n\nexport function setThreadRunning(state: BakendState, threadId: string, running: boolean) {\n  if (running) {\n    state.runningThreads.add(threadId);\n  } else {\n    state.runningThreads.delete(threadId);\n  }\n}\n\nexport function isThreadRunning(state: BakendState, threadId: string): boolean {\n  return state.runningThreads.has(threadId);\n}\n\nexport function enqueuePendingChat(state: BakendState, threadId: string, text: string) {\n  const existing = state.pendingChat.get(threadId) ?? [];\n  state.pendingChat.set(threadId, [...existing, text]);\n}\n\nexport function dequeuePendingChat(state: BakendState, threadId: string): string[] {\n  const pending = state.pendingChat.get(threadId) ?? [];\n  state.pendingChat.delete(threadId);\n  return pending;\n}\n\nexport function hasPendingChat(state: BakendState, threadId: string): boolean {\n  return (state.pendingChat.get(threadId)?.length ?? 0) > 0;\n}\n\n","import type { MutableRefObject } from \"react\";\nimport type { AppendMessage, ThreadMessageLike } from \"@assistant-ui/react\";\n\nimport type { BackendApi } from \"../backend/client\";\nimport type { AomiMessage } from \"../backend/types\";\nimport { toInboundMessage } from \"./utils\";\nimport type { ThreadContext } from \"../contexts/thread-context\";\nimport type { PollingController } from \"./polling-controller\";\nimport {\n  dequeuePendingChat,\n  enqueuePendingChat,\n  hasPendingChat,\n  isThreadReady,\n  resolveThreadId,\n  setThreadRunning,\n  type BakendState,\n} from \"../state/backend-state\";\n\ntype MessageControllerConfig = {\n  backendApiRef: MutableRefObject<BackendApi>;\n  backendStateRef: MutableRefObject<BakendState>;\n  threadContextRef: MutableRefObject<ThreadContext>;\n  polling: PollingController;\n  setGlobalIsRunning?: (running: boolean) => void;\n  getPublicKey?: () => string | undefined;\n};\n\ntype ThreadContextApi = Pick<\n  ThreadContext,\n  \"getThreadMessages\" | \"setThreadMessages\" | \"updateThreadMetadata\"\n>;\n\nexport class MessageController {\n  constructor(private readonly config: MessageControllerConfig) {}\n\n  inbound(threadId: string, msgs?: AomiMessage[] | null) {\n    const backendState = this.config.backendStateRef.current;\n    if (!msgs) return;\n    if (hasPendingChat(backendState, threadId)) {\n      // Avoid overwriting optimistic UI when pending user messages exist.\n      return;\n    }\n\n    const threadMessages: ThreadMessageLike[] = [];\n    for (const msg of msgs) {\n      const threadMessage = toInboundMessage(msg);\n      if (threadMessage) {\n        threadMessages.push(threadMessage);\n      }\n    }\n\n    this.getThreadContextApi().setThreadMessages(threadId, threadMessages);\n  }\n\n  async outbound(message: AppendMessage, threadId: string) {\n    const backendState = this.config.backendStateRef.current;\n    const text = message.content\n      .filter((part): part is Extract<typeof part, { type: \"text\" }> => part.type === \"text\")\n      .map((part: Extract<typeof message.content[number], { type: \"text\" }>) => part.text)\n      .join(\"\\n\");\n\n    if (!text) return;\n\n    const threadState = this.getThreadContextApi();\n    const existingMessages = threadState.getThreadMessages(threadId);\n    const userMessage: ThreadMessageLike = {\n      role: \"user\",\n      content: [{ type: \"text\", text }],\n      createdAt: new Date(),\n    };\n\n    threadState.setThreadMessages(threadId, [...existingMessages, userMessage]);\n    threadState.updateThreadMetadata(threadId, { lastActiveAt: new Date().toISOString() });\n\n    if (!isThreadReady(backendState, threadId)) {\n      this.markRunning(threadId, true);\n      enqueuePendingChat(backendState, threadId, text);\n      return;\n    }\n\n    const backendThreadId = resolveThreadId(backendState, threadId);\n    const publicKey = this.config.getPublicKey?.();\n\n    try {\n      this.markRunning(threadId, true);\n      const response = publicKey\n        ? await this.config.backendApiRef.current.postChatMessage(\n            backendThreadId,\n            text,\n            publicKey\n          )\n        : await this.config.backendApiRef.current.postChatMessage(backendThreadId, text);\n\n      // Apply the latest messages immediately so sync tool results appear without waiting for polling.\n      if (response?.messages) {\n        this.inbound(threadId, response.messages);\n      }\n\n      if (response?.is_processing) {\n        this.config.polling.start(threadId);\n      } else if (!this.config.polling.isPolling(threadId)) {\n        this.markRunning(threadId, false);\n      }\n    } catch (error) {\n      console.error(\"Failed to send message:\", error);\n      this.markRunning(threadId, false);\n    }\n  }\n\n  async flushPendingChat(threadId: string) {\n    const backendState = this.config.backendStateRef.current;\n    const pending = dequeuePendingChat(backendState, threadId);\n    if (!pending.length) return;\n    const backendThreadId = resolveThreadId(backendState, threadId);\n    const publicKey = this.config.getPublicKey?.();\n    for (const text of pending) {\n      try {\n        if (publicKey) {\n          await this.config.backendApiRef.current.postChatMessage(\n            backendThreadId,\n            text,\n            publicKey\n          );\n        } else {\n          await this.config.backendApiRef.current.postChatMessage(backendThreadId, text);\n        }\n      } catch (error) {\n        console.error(\"Failed to send queued message:\", error);\n      }\n    }\n    this.config.polling.start(threadId);\n  }\n\n  async cancel(threadId: string) {\n    const backendState = this.config.backendStateRef.current;\n    if (!isThreadReady(backendState, threadId)) return;\n    this.config.polling.stop(threadId);\n    const backendThreadId = resolveThreadId(backendState, threadId);\n    try {\n      await this.config.backendApiRef.current.postInterrupt(backendThreadId);\n      this.markRunning(threadId, false);\n    } catch (error) {\n      console.error(\"Failed to cancel:\", error);\n    }\n  }\n\n  private markRunning(threadId: string, running: boolean) {\n    setThreadRunning(this.config.backendStateRef.current, threadId, running);\n    if (this.config.threadContextRef.current.currentThreadId === threadId) {\n      this.config.setGlobalIsRunning?.(running);\n    }\n  }\n\n  private getThreadContextApi(): ThreadContextApi {\n    const { getThreadMessages, setThreadMessages, updateThreadMetadata } =\n      this.config.threadContextRef.current;\n    return { getThreadMessages, setThreadMessages, updateThreadMetadata };\n  }\n}\n","import type { MutableRefObject } from \"react\";\n\nimport type { BackendApi } from \"../backend/client\";\nimport type { AomiMessage, ApiStateResponse } from \"../backend/types\";\nimport {\n  isThreadReady,\n  resolveThreadId,\n  setThreadRunning,\n  type BakendState,\n} from \"../state/backend-state\";\n\ntype PollingConfig = {\n  backendApiRef: MutableRefObject<BackendApi>;\n  backendStateRef: MutableRefObject<BakendState>;\n  applyMessages: (threadId: string, messages?: AomiMessage[] | null) => void;\n  handleSystemEvents?: (\n    sessionId: string,\n    threadId: string,\n    events?: unknown[] | null\n  ) => void;\n  onStart?: (threadId: string) => void;\n  onStop?: (threadId: string) => void;\n  intervalMs?: number;\n};\n\nexport class PollingController {\n  private intervals = new Map<string, ReturnType<typeof setInterval>>();\n  private intervalMs: number;\n  private handleSystemEvents?: (\n    sessionId: string,\n    threadId: string,\n    events?: unknown[] | null\n  ) => void;\n\n  constructor(private readonly config: PollingConfig) {\n    this.intervalMs = config.intervalMs ?? 500;\n    this.handleSystemEvents = config.handleSystemEvents;\n  }\n\n  setSystemEventsHandler(\n    handler?: (sessionId: string, threadId: string, events?: unknown[] | null) => void\n  ) {\n    this.handleSystemEvents = handler;\n  }\n\n  start(threadId: string) {\n    const backendState = this.config.backendStateRef.current;\n    if (!isThreadReady(backendState, threadId)) return;\n    // Prevent starting if already polling\n    if (this.intervals.has(threadId)) {\n      return;\n    }\n\n    const backendThreadId = resolveThreadId(backendState, threadId);\n    setThreadRunning(backendState, threadId, true);\n\n    const tick = async () => {\n      // Check if polling was stopped before proceeding (handles race conditions)\n      if (!this.intervals.has(threadId)) {\n        return;\n      }\n\n      try {\n        console.log(\"[PollingController] Fetching state for threadId:\", threadId);\n        const state = await this.config.backendApiRef.current.fetchState(backendThreadId);\n\n        // Check again after async operation (polling might have been stopped)\n        if (!this.intervals.has(threadId)) {\n          return;\n        }\n\n        this.handleState(threadId, state);\n      } catch (error) {\n        console.error(\"Polling error:\", error);\n        this.stop(threadId);\n      }\n    };\n\n    const intervalId = setInterval(tick, this.intervalMs);\n    this.intervals.set(threadId, intervalId);\n\n    // Trigger onStart if provided (for setting isRunning state)\n    if (this.config.onStart) {\n      this.config.onStart(threadId);\n    }\n  }\n\n  stop(threadId: string) {\n    const intervalId = this.intervals.get(threadId);\n    if (intervalId) {\n      clearInterval(intervalId);\n      this.intervals.delete(threadId);\n    }\n    // Update state immediately to prevent any queued ticks from proceeding\n    setThreadRunning(this.config.backendStateRef.current, threadId, false);\n    this.config.onStop?.(threadId);\n  }\n\n  isPolling(threadId: string): boolean {\n    return this.intervals.has(threadId);\n  }\n\n  stopAll() {\n    for (const threadId of this.intervals.keys()) {\n      this.stop(threadId);\n    }\n  }\n\n  private handleState(threadId: string, state: ApiStateResponse) {\n    if (state.session_exists === false) {\n      this.stop(threadId);\n      return;\n    }\n\n    this.config.applyMessages(threadId, state.messages);\n\n    // Stop polling if backend explicitly indicates processing is complete\n    // or the flag is omitted.\n    if (!state.is_processing) {\n      this.stop(threadId);\n    }\n  }\n}\n","\"use client\";\n\nimport { useCallback, useEffect, useState } from \"react\";\nimport { useEventContext } from \"../contexts/event-context\";\nimport type { InboundEvent } from \"../state/event-buffer\";\n\n\nexport type WalletTxRequest = {\n  to: string;\n  value?: string;\n  data?: string;\n  chainId?: number;\n};\n\nexport type WalletTxComplete = {\n  txHash: string;\n  status: \"success\" | \"failed\";\n  amount?: string;\n  token?: string;\n};\n\nexport type WalletConnectionStatus = \"connected\" | \"disconnected\";\n\n\nexport type WalletHandlerConfig = {\n  sessionId: string;\n  onTxRequest?: (request: WalletTxRequest) => void;\n};\n\nexport type WalletHanderApi = {\n  /** Send transaction completion event to backend */\n  sendTxComplete: (tx: WalletTxComplete) => void;\n  /** Send wallet connection status change */\n  sendConnectionChange: (status: WalletConnectionStatus, address?: string) => void;\n  /** Pending transaction requests from AI */\n  pendingTxRequests: WalletTxRequest[];\n  /** Clear a pending request after handling */\n  clearTxRequest: (index: number) => void;\n};\n\nexport function useWalletHandler({\n  sessionId,\n  onTxRequest,\n}: WalletHandlerConfig): WalletHanderApi {\n  const { subscribe, sendOutbound } = useEventContext();\n  const [pendingTxRequests, setPendingTxRequests] = useState<WalletTxRequest[]>([]);\n\n  // ---------------------------------------------------------------------------\n  // Subscribe to wallet-related inbound events\n  // ---------------------------------------------------------------------------\n  useEffect(() => {\n    const unsubscribe = subscribe(\"wallet:tx_request\", (event: InboundEvent) => {\n      const request = event.payload as WalletTxRequest;\n\n      // Add to pending requests\n      setPendingTxRequests((prev) => [...prev, request]);\n\n      // Call optional callback\n      onTxRequest?.(request);\n    });\n\n    return unsubscribe;\n  }, [subscribe, onTxRequest]);\n\n  // ---------------------------------------------------------------------------\n  // Outbound: Send transaction completion\n  // ---------------------------------------------------------------------------\n  const sendTxComplete = useCallback(\n    (tx: WalletTxComplete) => {\n      sendOutbound({\n        type: \"wallet:tx_complete\",\n        sessionId,\n        payload: tx,\n        priority: \"high\",\n      });\n    },\n    [sendOutbound, sessionId]\n  );\n\n  // ---------------------------------------------------------------------------\n  // Outbound: Send connection status change\n  // ---------------------------------------------------------------------------\n  const sendConnectionChange = useCallback(\n    (status: WalletConnectionStatus, address?: string) => {\n      sendOutbound({\n        type: status === \"connected\" ? \"wallet:connected\" : \"wallet:disconnected\",\n        sessionId,\n        payload: { status, address },\n        priority: \"normal\",\n      });\n    },\n    [sendOutbound, sessionId]\n  );\n\n  // ---------------------------------------------------------------------------\n  // Clear handled request\n  // ---------------------------------------------------------------------------\n  const clearTxRequest = useCallback((index: number) => {\n    setPendingTxRequests((prev) => prev.filter((_, i) => i !== index));\n  }, []);\n\n  return {\n    sendTxComplete,\n    sendConnectionChange,\n    pendingTxRequests,\n    clearTxRequest,\n  };\n}\n","\"use client\";\n\nimport { useCallback, useEffect, useState } from \"react\";\nimport { useEventContext } from \"../contexts/event-context\";\nimport type { InboundEvent } from \"../state/event-buffer\";\n\n\nexport type Notification = {\n  id: string;\n  type: string;\n  title: string;\n  body?: unknown; // Could be JSON object or string\n  handled: boolean;\n  timestamp: number;\n  sessionId: string;\n};\n\n\nexport type NotificationHandlerConfig = {\n  /** Callback when new notification arrives */\n  onNotification?: (notification: Notification) => void;\n};\n\nexport type NotificationApi = {\n  /** All notifications */\n  notifications: Notification[];\n  /** Unhandled count */\n  unhandledCount: number;\n  /** Mark notification as handled */\n  markDone: (id: string) => void;\n};\n\nlet notificationIdCounter = 0;\nfunction generateNotificationId(): string {\n  return `notif-${Date.now()}-${++notificationIdCounter}`;\n}\n\nexport function useNotificationHandler({\n  onNotification,\n}: NotificationHandlerConfig = {}): NotificationApi {\n  const { subscribe } = useEventContext();\n  const [notifications, setNotifications] = useState<Notification[]>([]);\n\n  // ---------------------------------------------------------------------------\n  // Subscribe to notification events\n  // ---------------------------------------------------------------------------\n  useEffect(() => {\n    const unsubscribe = subscribe(\"notification\", (event: InboundEvent) => {\n      const payload = event.payload as Record<string, unknown>;\n\n      const notification: Notification = {\n        id: generateNotificationId(),\n        type: (payload.type as string) ?? \"notification\",\n        title: (payload.title as string) ?? \"Notification\",\n        body: payload.body,\n        handled: false,\n        timestamp: event.timestamp,\n        sessionId: event.sessionId,\n      };\n\n      setNotifications((prev) => [notification, ...prev]);\n      onNotification?.(notification);\n    });\n\n    return unsubscribe;\n  }, [subscribe, onNotification]);\n\n  // ---------------------------------------------------------------------------\n  // Computed: unhandled count\n  // ---------------------------------------------------------------------------\n  const unhandledCount = notifications.filter((n) => !n.handled).length;\n\n  // ---------------------------------------------------------------------------\n  // Actions\n  // ---------------------------------------------------------------------------\n  const markHandled = useCallback((id: string) => {\n    setNotifications((prev) =>\n      prev.map((n) => (n.id === id ? { ...n, handled: true } : n))\n    );\n  }, []);\n\n  return {\n    notifications,\n    unhandledCount,\n    markDone: markHandled,\n  };\n}\n"],"mappings":"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","names":["useEffect","useMemo","useRef","useCallback","useEffect","useRef","useState","createContext","useContext","useRef","jsx","createContext","useContext","useRef","useState","useCallback","useEffect","jsx","useRef","useEffect","useMemo","_a","useCallback","useEffect","useState","subscribe","useState","useEffect","useCallback","useCallback","useEffect","useState","subscribe","useState","useEffect","useCallback"]}